const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/troika-three-text.esm-Dv4dfK9D-CbbrrTSH.js","assets/index-D9chyKeb.js","assets/index-D0JW_tSo.css"])))=>i.map(i=>d[i]);
import{r as T,L as I,I as cr,S as He,e as Ce,c as je,v as On,$ as Ls,N as rt,Z as At,f as P,D as Q,l as ce,b as k,F as Is,a as Ne,V as ur,U as dr,q as hr,o as qt,d as $,g as ot,h as bt,i as ze,w as fr,B as pr,j as mr,k as gr,m as ke,n as Bs,p as gn,x as De,s as xr,t as xn,u as Os,y as Vn,A as vr,T as Gn,C as yr,E as vt,G as wr,H as Ar,J as br,K as Sr,M as Ns,O as Nn,R as _r,Y as Tr,W as Er,_ as zs,a0 as Mr,a1 as Pr,a2 as Cr,a3 as Rr,a4 as vn,a5 as Lr,a6 as Ir,a7 as qn,a8 as Br,a9 as Yt,aa as Or,ab as Us,ac as Nr,ad as zr,ae as Ur,af as Fr,ag as jr,ah as Dr,ai as Hr,aj as Fs,ak as kr,al as Vr,am as Gr,an as js,ao as qr,ap as Xr,aq as _e,ar as Kr,as as Xn,at as Wr,au as $r,av as yn,aw as Ds,ax as Yr,ay as gt,az as Hs,aA as Zr,aB as Qr}from"./index-D9chyKeb.js";import{v as Jr,y as ks,a as eo,K as Me,P as Vs,m as wn,A as it}from"./OrbitControls-DuFHF-v2-DcFGr2Is.js";const to=i=>typeof i=="object"&&typeof i.then=="function",Tt=[];function no(i,e,t=(s,n)=>s===n){if(i===e)return!0;if(!i||!e)return!1;const s=i.length;if(e.length!==s)return!1;for(let n=0;n<s;n++)if(!t(i[n],e[n]))return!1;return!0}function so(i,e=null,t=!1,s={}){e===null&&(e=[i]);for(const r of Tt)if(no(e,r.keys,r.equal)){if(t)return;if(Object.prototype.hasOwnProperty.call(r,"error"))throw r.error;if(Object.prototype.hasOwnProperty.call(r,"response"))return s.lifespan&&s.lifespan>0&&(r.timeout&&clearTimeout(r.timeout),r.timeout=setTimeout(r.remove,s.lifespan)),r.response;if(!t)throw r.promise}const n={keys:e,equal:s.equal,remove:()=>{const r=Tt.indexOf(n);r!==-1&&Tt.splice(r,1)},promise:(to(i)?i:i(...e)).then(r=>{n.response=r,s.lifespan&&s.lifespan>0&&(n.timeout=setTimeout(n.remove,s.lifespan))}).catch(r=>n.error=r)};if(Tt.push(n),!t)throw n.promise}const Kn=(i,e,t)=>so(i,e,!1,t);class ro extends He{constructor(e,t){super(),this.inputSource=null,this.xrControllerModel=null,this.index=e,this.controller=t.xr.getController(e),this.grip=t.xr.getControllerGrip(e),this.hand=t.xr.getHand(e),this.grip.userData.name="grip",this.controller.userData.name="controller",this.hand.userData.name="hand",this.visible=!1,this.add(this.controller,this.grip,this.hand),this._onConnected=this._onConnected.bind(this),this._onDisconnected=this._onDisconnected.bind(this),this.controller.addEventListener("connected",this._onConnected),this.controller.addEventListener("disconnected",this._onDisconnected)}_onConnected(e){e.fake||e.data&&(this.visible=!0,this.inputSource=e.data,this.dispatchEvent(e))}_onDisconnected(e){e.fake||(this.visible=!1,this.inputSource=null,this.dispatchEvent(e))}dispose(){this.controller.removeEventListener("connected",this._onConnected),this.controller.removeEventListener("disconnected",this._onDisconnected)}}var Wn,$n;const oo=i=>Array.from(new Set(i)),de=typeof window<"u"&&((Wn=window.document)!=null&&Wn.createElement||(($n=window.navigator)==null?void 0:$n.product)==="ReactNative")?T.useLayoutEffect:T.useEffect;function Se(i){const e=T.useRef(i);return de(()=>void(e.current=i),[i]),e}function qe(i,e,{handedness:t}={}){const s=Se(e),n=X(r=>r.controllers);de(()=>{const r=n.map(o=>{if(t&&o.inputSource&&o.inputSource.handedness!==t)return;const a=l=>s.current({nativeEvent:l,target:o});return o.controller.addEventListener(i,a),()=>o.controller.removeEventListener(i,a)});return()=>r.forEach(o=>o?.())},[n,t,i])}const Yn=new Q;function io({children:i}){const e=Me(u=>u.events),t=Me(u=>u.get),s=Me(u=>u.raycaster),n=X(u=>u.controllers),r=X(u=>u.interactions),o=X(u=>u.hoverState),a=X(u=>u.hasInteraction),l=X(u=>u.getInteraction),c=T.useCallback(u=>{const h=Array.from(r.keys());return Yn.identity().extractRotation(u.matrixWorld),s.ray.origin.setFromMatrixPosition(u.matrixWorld),s.ray.direction.set(0,0,-1).applyMatrix4(Yn),s.intersectObjects(h,!0)},[r,s]);it(()=>{var u;if(r.size!==0)for(const h of n){if(!((u=h.inputSource)!=null&&u.handedness))return;const f=o[h.inputSource.handedness],w=new Set;let g=c(h.controller);if(e.filter)g=e.filter(g,t());else{const m=g.find(p=>p?.object);m&&(g=[m])}for(const m of g){let p=m.object;for(;p;){if(a(p,"onHover")&&!f.has(p)){const v=l(p,"onHover");for(const y of v)y({target:h,intersection:m,intersections:g})}l(p,"onMove")?.forEach(v=>v({target:h,intersection:m,intersections:g})),f.set(p,m),w.add(p.id),p=p.parent}}for(const m of f.keys())if(!w.has(m.id)){f.delete(m);const p=l(m,"onBlur");if(!p)continue;for(const x of p)x({target:h,intersections:g})}}});const d=T.useCallback(u=>h=>{var f;if(!((f=h.target.inputSource)!=null&&f.handedness))return;const w=o[h.target.inputSource.handedness],g=Array.from(new Set(w.values()));r.forEach((m,p)=>{var x,v,y;if(w.has(p)){if(!m[u])return;for(const b of m[u])(x=b.current)==null||x.call(b,{target:h.target,intersection:w.get(p),intersections:g})}else if(u==="onSelect"&&m.onSelectMissed)for(const b of m.onSelectMissed)(v=b.current)==null||v.call(b,{target:h.target,intersections:g});else if(u==="onSqueeze"&&m.onSqueezeMissed)for(const b of m.onSqueezeMissed)(y=b.current)==null||y.call(b,{target:h.target,intersections:g})})},[o,r]);return qe("select",d("onSelect")),qe("selectstart",d("onSelectStart")),qe("selectend",d("onSelectEnd")),qe("squeeze",d("onSqueeze")),qe("squeezeend",d("onSqueezeEnd")),qe("squeezestart",d("onSqueezeStart")),T.createElement(T.Fragment,null,i)}function ge(i,e,t){const s=X(o=>o.addInteraction),n=X(o=>o.removeInteraction),r=Se(t);de(()=>{const o=i.current;if(!(!o||!r.current))return s(o,e,r),()=>n(o,e,r)},[i,e,s,n])}const ao=T.forwardRef(function({onHover:i,onBlur:e,onSelectStart:t,onSelectEnd:s,onSelectMissed:n,onSelect:r,onSqueezeStart:o,onSqueezeEnd:a,onSqueezeMissed:l,onSqueeze:c,onMove:d,children:u},h){const f=T.useRef(null);return T.useImperativeHandle(h,()=>f.current),ge(f,"onHover",i),ge(f,"onBlur",e),ge(f,"onSelectStart",t),ge(f,"onSelectEnd",s),ge(f,"onSelectMissed",n),ge(f,"onSelect",r),ge(f,"onSqueezeStart",o),ge(f,"onSqueezeEnd",a),ge(f,"onSqueezeMissed",l),ge(f,"onSqueeze",c),ge(f,"onMove",d),T.createElement("group",{ref:f},u)}),lo=T.forwardRef(function({onSelectStart:i,onSelectEnd:e,children:t,...s},n){const r=T.useRef(),o=T.useRef(null),a=T.useMemo(()=>new Q,[]);return T.useImperativeHandle(n,()=>o.current),it(()=>{const l=r.current,c=o.current;l&&(c.applyMatrix4(a),c.applyMatrix4(l.matrixWorld),c.updateMatrixWorld(),a.copy(l.matrixWorld).invert())}),T.createElement(ao,{ref:o,onSelectStart:l=>{r.current=l.target.controller,a.copy(l.target.controller.matrixWorld).invert(),i?.(l)},onSelectEnd:l=>{l.target.controller===r.current&&(r.current=void 0),e?.(l)},...s},t)}),Gs=T.createContext(null),Ve=ks((i,e)=>({set:i,get:e,session:null,referenceSpaceType:null}));function co({foveation:i=0,frameRate:e=void 0,referenceSpace:t="local-floor",onSessionStart:s,onSessionEnd:n,onVisibilityChange:r,onInputSourcesChange:o,children:a}){const l=Me(v=>v.gl),c=Me(v=>v.camera),d=X(v=>v.player),u=X(v=>v.get),h=X(v=>v.set),f=X(v=>v.session),w=X(v=>v.controllers),g=Se(s),m=Se(n),p=Se(r),x=Se(o);return de(()=>{const v=[0,1].map(y=>{const b=new ro(y,l),S=()=>h(_=>({controllers:[..._.controllers,b]})),A=()=>h(_=>({controllers:_.controllers.filter(E=>E!==b)}));return b.addEventListener("connected",S),b.addEventListener("disconnected",A),()=>{b.removeEventListener("connected",S),b.removeEventListener("disconnected",A)}});return()=>v.forEach(y=>y())},[l,h]),de(()=>Ve.subscribe(({session:v})=>h(()=>({session:v}))),[l.xr,h]),de(()=>{l.xr.setFoveation(i),h(()=>({foveation:i}))},[l.xr,i,h]),de(()=>{var v;try{e&&((v=f?.updateTargetFrameRate)==null||v.call(f,e))}catch{}h(()=>({frameRate:e}))},[f,e,h]),de(()=>{const v=Ve.getState();l.xr.setReferenceSpaceType(t),h(()=>({referenceSpace:t})),v.set({referenceSpaceType:t})},[l.xr,t,h]),de(()=>{if(!f)return void l.xr.setSession(null);const v=A=>{var _;h(()=>({isPresenting:!0})),(_=g.current)==null||_.call(g,{nativeEvent:{...A,target:f},target:f})},y=A=>{var _;h(()=>({isPresenting:!1,session:null})),Ve.setState(()=>({session:null})),(_=m.current)==null||_.call(m,{nativeEvent:{...A,target:f},target:f})},b=A=>{var _;(_=p.current)==null||_.call(p,{nativeEvent:A,target:f})},S=A=>{var _;const E=Object.values(f.inputSources).some(M=>M.hand);h(()=>({isHandTracking:E})),(_=x.current)==null||_.call(x,{nativeEvent:A,target:f})};return l.xr.addEventListener("sessionstart",v),l.xr.addEventListener("sessionend",y),f.addEventListener("visibilitychange",b),f.addEventListener("inputsourceschange",S),l.xr.setSession(f).then(()=>{l.xr.setFoveation(u().foveation)}),()=>{l.xr.removeEventListener("sessionstart",v),l.xr.removeEventListener("sessionend",y),f.removeEventListener("visibilitychange",b),f.removeEventListener("inputsourceschange",S)}},[f,l.xr,h,u]),T.createElement(io,null,T.createElement("primitive",{object:d},T.createElement("primitive",{object:c}),w.map(v=>T.createElement("primitive",{key:v.index,object:v}))),a)}function uo(i){const e=T.useMemo(()=>ks((t,s)=>({set:t,get:s,controllers:[],isPresenting:!1,isHandTracking:!1,player:new He,session:null,foveation:0,referenceSpace:"local-floor",hoverState:{left:new Map,right:new Map,none:new Map},interactions:new Map,hasInteraction(n,r){var o;return!!((o=s().interactions.get(n))!=null&&o[r].some(a=>a.current))},getInteraction(n,r){var o;return(o=s().interactions.get(n))==null?void 0:o[r].reduce((a,l)=>(l.current&&a.push(l.current),a),[])},addInteraction(n,r,o){const a=s().interactions;a.has(n)||a.set(n,{onHover:[],onBlur:[],onSelect:[],onSelectEnd:[],onSelectStart:[],onSelectMissed:[],onSqueeze:[],onSqueezeEnd:[],onSqueezeStart:[],onSqueezeMissed:[],onMove:[]}),a.get(n)[r].push(o)},removeInteraction(n,r,o){const a=s().interactions.get(n);if(a){const l=a[r].indexOf(o);l!==-1&&a[r].splice(l,1)}}})),[]);return T.createElement(Gs.Provider,{value:e},T.createElement(co,{...i}))}const ho=(i,e)=>{var t;if(!(!i&&!e))return i&&!e?{optionalFeatures:[i]}:i&&e?{...e,optionalFeatures:oo([...(t=e.optionalFeatures)!=null?t:[],i])}:e},fo=async(i,e)=>{const t=Ve.getState();if(t.session){console.warn("@react-three/xr: session already started, please stop it first");return}const s=ho(t.referenceSpaceType,e),n=await navigator.xr.requestSession(i,s);return t.set(()=>({session:n})),n},po=async()=>{const i=Ve.getState();if(!i.session){console.warn("@react-three/xr: no session to stop, please start it first");return}await i.session.end(),i.set({session:null})},mo=async(i,{sessionInit:e,enterOnly:t,exitOnly:s}={})=>{const n=Ve.getState();if(!(n.session&&t)&&!(!n.session&&s))return n.session?await po():await fo(i,e)},go=(i,e,t)=>{switch(i){case"entered":return`Exit ${e}`;case"exited":return`Enter ${e}`;case"unsupported":default:switch(t){case"https":return"HTTPS needed";case"security":return`${e} blocked`;case"unknown":default:return`${e} unsupported`}}},zn=T.forwardRef(function({mode:i,sessionInit:e,enterOnly:t=!1,exitOnly:s=!1,onClick:n,onError:r,children:o,...a},l){var c;const[d,u]=T.useState("exited"),[h,f]=T.useState("unknown"),w=go(d,i,h),g=i==="inline"?i:`immersive-${i.toLowerCase()}`,m=Se(r);de(()=>{if(!navigator?.xr)return void u("unsupported");navigator.xr.isSessionSupported(g).then(x=>{if(x)u("exited");else{const v=location.protocol==="https:";u("unsupported"),f(v?"unknown":"https")}}).catch(x=>{u("unsupported"),"name"in x&&x.name==="SecurityError"?f("security"):f("unknown")})},[g]),de(()=>Ve.subscribe(x=>{x.session?u("entered"):d!=="unsupported"&&u("exited")}),[d]);const p=T.useCallback(async x=>{n?.(x);try{mo(g,{sessionInit:e,enterOnly:t,exitOnly:s})}catch(v){const y=m.current;if(y&&v instanceof Error)y(v);else throw v}},[n,g,e,t,s,m]);return T.createElement("button",{...a,ref:l,onClick:d==="unsupported"?n:p},(c=typeof o=="function"?o(d):o)!=null?c:w)}),qs={position:"absolute",bottom:"24px",left:"50%",transform:"translateX(-50%)",padding:"12px 24px",border:"1px solid white",borderRadius:"4px",background:"rgba(0, 0, 0, 0.1)",color:"white",font:"normal 0.8125rem sans-serif",outline:"none",zIndex:99999,cursor:"pointer"};T.forwardRef(({style:i=qs,sessionInit:e={domOverlay:typeof document<"u"?{root:document.body}:void 0,optionalFeatures:["hit-test","dom-overlay","dom-overlay-for-handheld-ar"]},children:t,...s},n)=>T.createElement(zn,{...s,ref:n,mode:"AR",style:i,sessionInit:e},t));T.forwardRef(({style:i=qs,sessionInit:e={optionalFeatures:["local-floor","bounded-floor","hand-tracking","layers"]},children:t,...s},n)=>T.createElement(zn,{...s,ref:n,mode:"VR",style:i,sessionInit:e},t));function X(i=t=>t,e){const t=T.useContext(Gs);if(!t)throw new Error("useXR must be used within an <XR /> component!");return t(i,e)}function Zn(i,e){if(e===$r)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),i;if(e===yn||e===Ds){let t=i.getIndex();if(t===null){const o=[],a=i.getAttribute("position");if(a!==void 0){for(let l=0;l<a.count;l++)o.push(l);i.setIndex(o),t=i.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),i}const s=t.count-2,n=[];if(t)if(e===yn)for(let o=1;o<=s;o++)n.push(t.getX(0)),n.push(t.getX(o)),n.push(t.getX(o+1));else for(let o=0;o<s;o++)o%2===0?(n.push(t.getX(o)),n.push(t.getX(o+1)),n.push(t.getX(o+2))):(n.push(t.getX(o+2)),n.push(t.getX(o+1)),n.push(t.getX(o)));n.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=i.clone();return r.setIndex(n),r.clearGroups(),r}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),i}const xo=parseInt(Os.replace(/\D+/g,""));class Xs extends gr{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new bo(t)}),this.register(function(t){return new Ro(t)}),this.register(function(t){return new Lo(t)}),this.register(function(t){return new Io(t)}),this.register(function(t){return new _o(t)}),this.register(function(t){return new To(t)}),this.register(function(t){return new Eo(t)}),this.register(function(t){return new Mo(t)}),this.register(function(t){return new Ao(t)}),this.register(function(t){return new Po(t)}),this.register(function(t){return new So(t)}),this.register(function(t){return new Co(t)}),this.register(function(t){return new yo(t)}),this.register(function(t){return new Bo(t)}),this.register(function(t){return new Oo(t)})}load(e,t,s,n){const r=this;let o;this.resourcePath!==""?o=this.resourcePath:this.path!==""?o=this.path:o=ke.extractUrlBase(e),this.manager.itemStart(e);const a=function(c){n?n(c):console.error(c),r.manager.itemError(e),r.manager.itemEnd(e)},l=new Bs(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(c){try{r.parse(c,o,function(d){t(d),r.manager.itemEnd(e)},a)}catch(d){a(d)}},s,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){let r;const o={},a={};if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(ke.decodeText(new Uint8Array(e.slice(0,4)))===Ks){try{o[U.KHR_BINARY_GLTF]=new No(e)}catch(c){n&&n(c);return}r=JSON.parse(o[U.KHR_BINARY_GLTF].content)}else r=JSON.parse(ke.decodeText(new Uint8Array(e)));else r=e;if(r.asset===void 0||r.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new Wo(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const d=this.pluginCallbacks[c](l);a[d.name]=d,o[d.name]=!0}if(r.extensionsUsed)for(let c=0;c<r.extensionsUsed.length;++c){const d=r.extensionsUsed[c],u=r.extensionsRequired||[];switch(d){case U.KHR_MATERIALS_UNLIT:o[d]=new wo;break;case U.KHR_DRACO_MESH_COMPRESSION:o[d]=new zo(r,this.dracoLoader);break;case U.KHR_TEXTURE_TRANSFORM:o[d]=new Uo;break;case U.KHR_MESH_QUANTIZATION:o[d]=new Fo;break;default:u.indexOf(d)>=0&&a[d]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+d+'".')}}l.setExtensions(o),l.setPlugins(a),l.parse(s,n)}parseAsync(e,t){const s=this;return new Promise(function(n,r){s.parse(e,t,n,r)})}}function vo(){let i={};return{get:function(e){return i[e]},add:function(e,t){i[e]=t},remove:function(e){delete i[e]},removeAll:function(){i={}}}}const U={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class yo{constructor(e){this.parser=e,this.name=U.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,n=t.length;s<n;s++){const r=t[s];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let n=t.cache.get(s);if(n)return n;const r=t.json,o=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let a;const l=new ze(16777215);o.color!==void 0&&l.fromArray(o.color);const c=o.range!==void 0?o.range:0;switch(o.type){case"directional":a=new br(l),a.target.position.set(0,0,-1),a.add(a.target);break;case"point":a=new Ar(l),a.distance=c;break;case"spot":a=new wr(l),a.distance=c,o.spot=o.spot||{},o.spot.innerConeAngle=o.spot.innerConeAngle!==void 0?o.spot.innerConeAngle:0,o.spot.outerConeAngle=o.spot.outerConeAngle!==void 0?o.spot.outerConeAngle:Math.PI/4,a.angle=o.spot.outerConeAngle,a.penumbra=1-o.spot.innerConeAngle/o.spot.outerConeAngle,a.target.position.set(0,0,-1),a.add(a.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+o.type)}return a.position.set(0,0,0),a.decay=2,Ie(a,o),o.intensity!==void 0&&(a.intensity=o.intensity),a.name=t.createUniqueName(o.name||"light_"+e),n=Promise.resolve(a),t.cache.add(s,n),n}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,n=s.json.nodes[e],r=(n.extensions&&n.extensions[this.name]||{}).light;return r===void 0?null:this._loadLight(r).then(function(o){return s._getNodeRef(t.cache,r,o)})}}class wo{constructor(){this.name=U.KHR_MATERIALS_UNLIT}getMaterialType(){return je}extendParams(e,t,s){const n=[];e.color=new ze(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const o=r.baseColorFactor;e.color.fromArray(o),e.opacity=o[3]}r.baseColorTexture!==void 0&&n.push(s.assignTexture(e,"map",r.baseColorTexture,3001))}return Promise.all(n)}}class Ao{constructor(e){this.parser=e,this.name=U.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const n=s.extensions[this.name].emissiveStrength;return n!==void 0&&(t.emissiveIntensity=n),Promise.resolve()}}class bo{constructor(e){this.parser=e,this.name=U.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const t=this.parser.json.materials[e];return!t.extensions||!t.extensions[this.name]?null:Ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],o=n.extensions[this.name];if(o.clearcoatFactor!==void 0&&(t.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(r.push(s.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const a=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new k(a,a)}return Promise.all(r)}}class So{constructor(e){this.parser=e,this.name=U.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const t=this.parser.json.materials[e];return!t.extensions||!t.extensions[this.name]?null:Ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],o=n.extensions[this.name];return o.iridescenceFactor!==void 0&&(t.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(t.iridescenceIOR=o.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(r)}}class _o{constructor(e){this.parser=e,this.name=U.KHR_MATERIALS_SHEEN}getMaterialType(e){const t=this.parser.json.materials[e];return!t.extensions||!t.extensions[this.name]?null:Ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new ze(0,0,0),t.sheenRoughness=0,t.sheen=1;const o=n.extensions[this.name];return o.sheenColorFactor!==void 0&&t.sheenColor.fromArray(o.sheenColorFactor),o.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&r.push(s.assignTexture(t,"sheenColorMap",o.sheenColorTexture,3001)),o.sheenRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(r)}}class To{constructor(e){this.parser=e,this.name=U.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const t=this.parser.json.materials[e];return!t.extensions||!t.extensions[this.name]?null:Ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],o=n.extensions[this.name];return o.transmissionFactor!==void 0&&(t.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&r.push(s.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(r)}}class Eo{constructor(e){this.parser=e,this.name=U.KHR_MATERIALS_VOLUME}getMaterialType(e){const t=this.parser.json.materials[e];return!t.extensions||!t.extensions[this.name]?null:Ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],o=n.extensions[this.name];t.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&r.push(s.assignTexture(t,"thicknessMap",o.thicknessTexture)),t.attenuationDistance=o.attenuationDistance||1/0;const a=o.attenuationColor||[1,1,1];return t.attenuationColor=new ze(a[0],a[1],a[2]),Promise.all(r)}}class Mo{constructor(e){this.parser=e,this.name=U.KHR_MATERIALS_IOR}getMaterialType(e){const t=this.parser.json.materials[e];return!t.extensions||!t.extensions[this.name]?null:Ce}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const n=s.extensions[this.name];return t.ior=n.ior!==void 0?n.ior:1.5,Promise.resolve()}}class Po{constructor(e){this.parser=e,this.name=U.KHR_MATERIALS_SPECULAR}getMaterialType(e){const t=this.parser.json.materials[e];return!t.extensions||!t.extensions[this.name]?null:Ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],o=n.extensions[this.name];t.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&r.push(s.assignTexture(t,"specularIntensityMap",o.specularTexture));const a=o.specularColorFactor||[1,1,1];return t.specularColor=new ze(a[0],a[1],a[2]),o.specularColorTexture!==void 0&&r.push(s.assignTexture(t,"specularColorMap",o.specularColorTexture,3001)),Promise.all(r)}}class Co{constructor(e){this.parser=e,this.name=U.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const t=this.parser.json.materials[e];return!t.extensions||!t.extensions[this.name]?null:Ce}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],o=n.extensions[this.name];return o.anisotropyStrength!==void 0&&(t.anisotropy=o.anisotropyStrength),o.anisotropyRotation!==void 0&&(t.anisotropyRotation=o.anisotropyRotation),o.anisotropyTexture!==void 0&&r.push(s.assignTexture(t,"anisotropyMap",o.anisotropyTexture)),Promise.all(r)}}class Ro{constructor(e){this.parser=e,this.name=U.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,n=s.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const r=n.extensions[this.name],o=t.options.ktx2Loader;if(!o){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,o)}}class Lo{constructor(e){this.parser=e,this.name=U.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,n=s.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const o=r.extensions[t],a=n.images[o.source];let l=s.textureLoader;if(a.uri){const c=s.options.manager.getHandler(a.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return s.loadTextureImage(e,o.source,l);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class Io{constructor(e){this.parser=e,this.name=U.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,n=s.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const o=r.extensions[t],a=n.images[o.source];let l=s.textureLoader;if(a.uri){const c=s.options.manager.getHandler(a.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return s.loadTextureImage(e,o.source,l);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class Bo{constructor(e){this.name=U.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const n=s.extensions[this.name],r=this.parser.getDependency("buffer",n.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(a){const l=n.byteOffset||0,c=n.byteLength||0,d=n.count,u=n.byteStride,h=new Uint8Array(a,l,c);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(d,u,h,n.mode,n.filter).then(function(f){return f.buffer}):o.ready.then(function(){const f=new ArrayBuffer(d*u);return o.decodeGltfBuffer(new Uint8Array(f),d,u,h,n.mode,n.filter),f})})}else return null}}class Oo{constructor(e){this.name=U.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const n=t.meshes[s.mesh];for(const l of n.primitives)if(l.mode!==ue.TRIANGLES&&l.mode!==ue.TRIANGLE_STRIP&&l.mode!==ue.TRIANGLE_FAN&&l.mode!==void 0)return null;const r=s.extensions[this.name].attributes,o=[],a={};for(const l in r)o.push(this.parser.getDependency("accessor",r[l]).then(c=>(a[l]=c,a[l])));return o.length<1?null:(o.push(this.parser.createNodeMesh(e)),Promise.all(o).then(l=>{const c=l.pop(),d=c.isGroup?c.children:[c],u=l[0].count,h=[];for(const f of d){const w=new Q,g=new P,m=new Ns,p=new P(1,1,1),x=new Sr(f.geometry,f.material,u);for(let v=0;v<u;v++)a.TRANSLATION&&g.fromBufferAttribute(a.TRANSLATION,v),a.ROTATION&&m.fromBufferAttribute(a.ROTATION,v),a.SCALE&&p.fromBufferAttribute(a.SCALE,v),x.setMatrixAt(v,w.compose(g,m,p));for(const v in a)v!=="TRANSLATION"&&v!=="ROTATION"&&v!=="SCALE"&&f.geometry.setAttribute(v,a[v]);Nn.prototype.copy.call(x,f),this.parser.assignFinalMaterial(x),h.push(x)}return c.isGroup?(c.clear(),c.add(...h),c):h[0]}))}}const Ks="glTF",ct=12,Qn={JSON:1313821514,BIN:5130562};class No{constructor(e){this.name=U.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,ct);if(this.header={magic:ke.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Ks)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const s=this.header.length-ct,n=new DataView(e,ct);let r=0;for(;r<s;){const o=n.getUint32(r,!0);r+=4;const a=n.getUint32(r,!0);if(r+=4,a===Qn.JSON){const l=new Uint8Array(e,ct+r,o);this.content=ke.decodeText(l)}else if(a===Qn.BIN){const l=ct+r;this.body=e.slice(l,l+o)}r+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class zo{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=U.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,n=this.dracoLoader,r=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,a={},l={},c={};for(const d in o){const u=An[d]||d.toLowerCase();a[u]=o[d]}for(const d in e.attributes){const u=An[d]||d.toLowerCase();if(o[d]!==void 0){const h=s.accessors[e.attributes[d]],f=st[h.componentType];c[u]=f.name,l[u]=h.normalized===!0}}return t.getDependency("bufferView",r).then(function(d){return new Promise(function(u){n.decodeDracoFile(d,function(h){for(const f in h.attributes){const w=h.attributes[f],g=l[f];g!==void 0&&(w.normalized=g)}u(h)},a,c)})})}}class Uo{constructor(){this.name=U.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class Fo{constructor(){this.name=U.KHR_MESH_QUANTIZATION}}class Ws extends Yr{constructor(e,t,s,n){super(e,t,s,n)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,n=this.valueSize,r=e*n*3+n;for(let o=0;o!==n;o++)t[o]=s[r+o];return t}interpolate_(e,t,s,n){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=a*2,c=a*3,d=n-t,u=(s-t)/d,h=u*u,f=h*u,w=e*c,g=w-c,m=-2*f+3*h,p=f-h,x=1-m,v=p-h+u;for(let y=0;y!==a;y++){const b=o[g+y+a],S=o[g+y+l]*d,A=o[w+y+a],_=o[w+y]*d;r[y]=x*b+v*S+m*A+p*_}return r}}const jo=new Ns;class Do extends Ws{interpolate_(e,t,s,n){const r=super.interpolate_(e,t,s,n);return jo.fromArray(r).normalize().toArray(r),r}}const ue={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},st={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Jn={9728:Rr,9729:qt,9984:Cr,9985:Pr,9986:Mr,9987:zs},es={33071:Ir,33648:Lr,10497:vn},Zt={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},An={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",...xo>=152?{TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3"}:{TEXCOORD_0:"uv",TEXCOORD_1:"uv2"},COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Re={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Ho={CUBICSPLINE:void 0,LINEAR:js,STEP:Gr},Qt={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function ko(i){return i.DefaultMaterial===void 0&&(i.DefaultMaterial=new On({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:rt})),i.DefaultMaterial}function Fe(i,e,t){for(const s in t.extensions)i[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function Ie(i,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(i.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Vo(i,e,t){let s=!1,n=!1,r=!1;for(let c=0,d=e.length;c<d;c++){const u=e[c];if(u.POSITION!==void 0&&(s=!0),u.NORMAL!==void 0&&(n=!0),u.COLOR_0!==void 0&&(r=!0),s&&n&&r)break}if(!s&&!n&&!r)return Promise.resolve(i);const o=[],a=[],l=[];for(let c=0,d=e.length;c<d;c++){const u=e[c];if(s){const h=u.POSITION!==void 0?t.getDependency("accessor",u.POSITION):i.attributes.position;o.push(h)}if(n){const h=u.NORMAL!==void 0?t.getDependency("accessor",u.NORMAL):i.attributes.normal;a.push(h)}if(r){const h=u.COLOR_0!==void 0?t.getDependency("accessor",u.COLOR_0):i.attributes.color;l.push(h)}}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(l)]).then(function(c){const d=c[0],u=c[1],h=c[2];return s&&(i.morphAttributes.position=d),n&&(i.morphAttributes.normal=u),r&&(i.morphAttributes.color=h),i.morphTargetsRelative=!0,i})}function Go(i,e){if(i.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)i.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(i.morphTargetInfluences.length===t.length){i.morphTargetDictionary={};for(let s=0,n=t.length;s<n;s++)i.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function qo(i){let e;const t=i.extensions&&i.extensions[U.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+Jt(t.attributes):e=i.indices+":"+Jt(i.attributes)+":"+i.mode,i.targets!==void 0)for(let s=0,n=i.targets.length;s<n;s++)e+=":"+Jt(i.targets[s]);return e}function Jt(i){let e="";const t=Object.keys(i).sort();for(let s=0,n=t.length;s<n;s++)e+=t[s]+":"+i[t[s]]+";";return e}function bn(i){switch(i){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function Xo(i){return i.search(/\.jpe?g($|\?)/i)>0||i.search(/^data\:image\/jpeg/)===0?"image/jpeg":i.search(/\.webp($|\?)/i)>0||i.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const Ko=new Q;class Wo{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new vo,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,n=!1,r=-1;typeof navigator<"u"&&typeof navigator.userAgent<"u"&&(s=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,n=navigator.userAgent.indexOf("Firefox")>-1,r=n?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||s||n&&r<98?this.textureLoader=new _r(this.options.manager):this.textureLoader=new Tr(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Bs(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,n=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(o){const a={scene:o[0][n.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:n.asset,parser:s,userData:{}};Fe(r,a,n),Ie(a,n),Promise.all(s._invokeAll(function(l){return l.afterRoot&&l.afterRoot(a)})).then(function(){e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let n=0,r=t.length;n<r;n++){const o=t[n].joints;for(let a=0,l=o.length;a<l;a++)e[o[a]].isBone=!0}for(let n=0,r=e.length;n<r;n++){const o=e[n];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(s[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const n=s.clone(),r=(o,a)=>{const l=this.associations.get(o);l!=null&&this.associations.set(a,l);for(const[c,d]of o.children.entries())r(d,a.children[c])};return r(s,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let n=0;n<t.length;n++){const r=e(t[n]);r&&s.push(r)}return s}getDependency(e,t){const s=e+":"+t;let n=this.cache.get(s);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne(function(r){return r.loadNode&&r.loadNode(t)});break;case"mesh":n=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":n=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":n=this.loadCamera(t);break;default:if(n=this._invokeOne(function(r){return r!=this&&r.getDependency&&r.getDependency(e,t)}),!n)throw new Error("Unknown type: "+e);break}this.cache.add(s,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,n=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(n.map(function(r,o){return s.getDependency(e,o)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[U.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(r,o){s.load(ke.resolveURL(t.uri,n.path),r,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const n=t.byteLength||0,r=t.byteOffset||0;return s.slice(r,r+n)})}loadAccessor(e){const t=this,s=this.json,n=this.json.accessors[e];if(n.bufferView===void 0&&n.sparse===void 0){const o=Zt[n.type],a=st[n.componentType],l=n.normalized===!0,c=new a(n.count*o);return Promise.resolve(new vt(c,o,l))}const r=[];return n.bufferView!==void 0?r.push(this.getDependency("bufferView",n.bufferView)):r.push(null),n.sparse!==void 0&&(r.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(r).then(function(o){const a=o[0],l=Zt[n.type],c=st[n.componentType],d=c.BYTES_PER_ELEMENT,u=d*l,h=n.byteOffset||0,f=n.bufferView!==void 0?s.bufferViews[n.bufferView].byteStride:void 0,w=n.normalized===!0;let g,m;if(f&&f!==u){const p=Math.floor(h/f),x="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+p+":"+n.count;let v=t.cache.get(x);v||(g=new c(a,p*f,n.count*f/d),v=new Er(g,f/d),t.cache.add(x,v)),m=new De(v,l,h%f/d,w)}else a===null?g=new c(n.count*l):g=new c(a,h,n.count*l),m=new vt(g,l,w);if(n.sparse!==void 0){const p=Zt.SCALAR,x=st[n.sparse.indices.componentType],v=n.sparse.indices.byteOffset||0,y=n.sparse.values.byteOffset||0,b=new x(o[1],v,n.sparse.count*p),S=new c(o[2],y,n.sparse.count*l);a!==null&&(m=new vt(m.array.slice(),m.itemSize,m.normalized));for(let A=0,_=b.length;A<_;A++){const E=b[A];if(m.setX(E,S[A*l]),l>=2&&m.setY(E,S[A*l+1]),l>=3&&m.setZ(E,S[A*l+2]),l>=4&&m.setW(E,S[A*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return m})}loadTexture(e){const t=this.json,s=this.options,n=t.textures[e].source,r=t.images[n];let o=this.textureLoader;if(r.uri){const a=s.manager.getHandler(r.uri);a!==null&&(o=a)}return this.loadTextureImage(e,n,o)}loadTextureImage(e,t,s){const n=this,r=this.json,o=r.textures[e],a=r.images[t],l=(a.uri||a.bufferView)+":"+o.sampler;if(this.textureCache[l])return this.textureCache[l];const c=this.loadImageSource(t,s).then(function(d){d.flipY=!1,d.name=o.name||a.name||"",d.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(d.name=a.uri);const u=(r.samplers||{})[o.sampler]||{};return d.magFilter=Jn[u.magFilter]||qt,d.minFilter=Jn[u.minFilter]||zs,d.wrapS=es[u.wrapS]||vn,d.wrapT=es[u.wrapT]||vn,n.associations.set(d,{textures:e}),d}).catch(function(){return null});return this.textureCache[l]=c,c}loadImageSource(e,t){const s=this,n=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(u=>u.clone());const o=n.images[e],a=self.URL||self.webkitURL;let l=o.uri||"",c=!1;if(o.bufferView!==void 0)l=s.getDependency("bufferView",o.bufferView).then(function(u){c=!0;const h=new Blob([u],{type:o.mimeType});return l=a.createObjectURL(h),l});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const d=Promise.resolve(l).then(function(u){return new Promise(function(h,f){let w=h;t.isImageBitmapLoader===!0&&(w=function(g){const m=new qn(g);m.needsUpdate=!0,h(m)}),t.load(ke.resolveURL(u,r.path),w,void 0,f)})}).then(function(u){return c===!0&&a.revokeObjectURL(l),u.userData.mimeType=o.mimeType||Xo(o.uri),u}).catch(function(u){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),u});return this.sourceCache[e]=d,d}assignTexture(e,t,s,n){const r=this;return this.getDependency("texture",s.index).then(function(o){if(!o)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(o=o.clone(),o.channel=s.texCoord),r.extensions[U.KHR_TEXTURE_TRANSFORM]){const a=s.extensions!==void 0?s.extensions[U.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const l=r.associations.get(o);o=r.extensions[U.KHR_TEXTURE_TRANSFORM].extendTexture(o,a),r.associations.set(o,l)}}return n!==void 0&&("colorSpace"in o?o.colorSpace=n===3001?"srgb":"srgb-linear":o.encoding=n),e[t]=o,o})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const n=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,o=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+s.uuid;let l=this.cache.get(a);l||(l=new Br,Yt.prototype.copy.call(l,s),l.color.copy(s.color),l.map=s.map,l.sizeAttenuation=!1,this.cache.add(a,l)),s=l}else if(e.isLine){const a="LineBasicMaterial:"+s.uuid;let l=this.cache.get(a);l||(l=new Or,Yt.prototype.copy.call(l,s),l.color.copy(s.color),l.map=s.map,this.cache.add(a,l)),s=l}if(n||r||o){let a="ClonedMaterial:"+s.uuid+":";n&&(a+="derivative-tangents:"),r&&(a+="vertex-colors:"),o&&(a+="flat-shading:");let l=this.cache.get(a);l||(l=s.clone(),r&&(l.vertexColors=!0),o&&(l.flatShading=!0),n&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(a,l),this.associations.set(l,this.associations.get(s))),s=l}e.material=s}getMaterialType(){return On}loadMaterial(e){const t=this,s=this.json,n=this.extensions,r=s.materials[e];let o;const a={},l=r.extensions||{},c=[];if(l[U.KHR_MATERIALS_UNLIT]){const u=n[U.KHR_MATERIALS_UNLIT];o=u.getMaterialType(),c.push(u.extendParams(a,r,t))}else{const u=r.pbrMetallicRoughness||{};if(a.color=new ze(1,1,1),a.opacity=1,Array.isArray(u.baseColorFactor)){const h=u.baseColorFactor;a.color.fromArray(h),a.opacity=h[3]}u.baseColorTexture!==void 0&&c.push(t.assignTexture(a,"map",u.baseColorTexture,3001)),a.metalness=u.metallicFactor!==void 0?u.metallicFactor:1,a.roughness=u.roughnessFactor!==void 0?u.roughnessFactor:1,u.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(a,"metalnessMap",u.metallicRoughnessTexture)),c.push(t.assignTexture(a,"roughnessMap",u.metallicRoughnessTexture))),o=this._invokeOne(function(h){return h.getMaterialType&&h.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(h){return h.extendMaterialParams&&h.extendMaterialParams(e,a)})))}r.doubleSided===!0&&(a.side=Us);const d=r.alphaMode||Qt.OPAQUE;if(d===Qt.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,d===Qt.MASK&&(a.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&o!==je&&(c.push(t.assignTexture(a,"normalMap",r.normalTexture)),a.normalScale=new k(1,1),r.normalTexture.scale!==void 0)){const u=r.normalTexture.scale;a.normalScale.set(u,u)}return r.occlusionTexture!==void 0&&o!==je&&(c.push(t.assignTexture(a,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&o!==je&&(a.emissive=new ze().fromArray(r.emissiveFactor)),r.emissiveTexture!==void 0&&o!==je&&c.push(t.assignTexture(a,"emissiveMap",r.emissiveTexture,3001)),Promise.all(c).then(function(){const u=new o(a);return r.name&&(u.name=r.name),Ie(u,r),t.associations.set(u,{materials:e}),r.extensions&&Fe(n,u,r),u})}createUniqueName(e){const t=Nr.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,n=this.primitiveCache;function r(a){return s[U.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(l){return ts(l,a,t)})}const o=[];for(let a=0,l=e.length;a<l;a++){const c=e[a],d=qo(c),u=n[d];if(u)o.push(u.promise);else{let h;c.extensions&&c.extensions[U.KHR_DRACO_MESH_COMPRESSION]?h=r(c):h=ts(new Is,c,t),n[d]={primitive:c,promise:h},o.push(h)}}return Promise.all(o)}loadMesh(e){const t=this,s=this.json,n=this.extensions,r=s.meshes[e],o=r.primitives,a=[];for(let l=0,c=o.length;l<c;l++){const d=o[l].material===void 0?ko(this.cache):this.getDependency("material",o[l].material);a.push(d)}return a.push(t.loadGeometries(o)),Promise.all(a).then(function(l){const c=l.slice(0,l.length-1),d=l[l.length-1],u=[];for(let f=0,w=d.length;f<w;f++){const g=d[f],m=o[f];let p;const x=c[f];if(m.mode===ue.TRIANGLES||m.mode===ue.TRIANGLE_STRIP||m.mode===ue.TRIANGLE_FAN||m.mode===void 0)p=r.isSkinnedMesh===!0?new zr(g,x):new Ne(g,x),p.isSkinnedMesh===!0&&p.normalizeSkinWeights(),m.mode===ue.TRIANGLE_STRIP?p.geometry=Zn(p.geometry,Ds):m.mode===ue.TRIANGLE_FAN&&(p.geometry=Zn(p.geometry,yn));else if(m.mode===ue.LINES)p=new Ur(g,x);else if(m.mode===ue.LINE_STRIP)p=new Fr(g,x);else if(m.mode===ue.LINE_LOOP)p=new jr(g,x);else if(m.mode===ue.POINTS)p=new Dr(g,x);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+m.mode);Object.keys(p.geometry.morphAttributes).length>0&&Go(p,r),p.name=t.createUniqueName(r.name||"mesh_"+e),Ie(p,r),m.extensions&&Fe(n,p,m),t.assignFinalMaterial(p),u.push(p)}for(let f=0,w=u.length;f<w;f++)t.associations.set(u[f],{meshes:e,primitives:f});if(u.length===1)return r.extensions&&Fe(n,u[0],r),u[0];const h=new He;r.extensions&&Fe(n,h,r),t.associations.set(h,{meshes:e});for(let f=0,w=u.length;f<w;f++)h.add(u[f]);return h})}loadCamera(e){let t;const s=this.json.cameras[e],n=s[s.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new Hr(Fs.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):s.type==="orthographic"&&(t=new kr(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),Ie(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let n=0,r=t.joints.length;n<r;n++)s.push(this._loadNodeShallow(t.joints[n]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(n){const r=n.pop(),o=n,a=[],l=[];for(let c=0,d=o.length;c<d;c++){const u=o[c];if(u){a.push(u);const h=new Q;r!==null&&h.fromArray(r.array,c*16),l.push(h)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[c])}return new Vr(a,l)})}loadAnimation(e){const t=this.json.animations[e],s=t.name?t.name:"animation_"+e,n=[],r=[],o=[],a=[],l=[];for(let c=0,d=t.channels.length;c<d;c++){const u=t.channels[c],h=t.samplers[u.sampler],f=u.target,w=f.node,g=t.parameters!==void 0?t.parameters[h.input]:h.input,m=t.parameters!==void 0?t.parameters[h.output]:h.output;f.node!==void 0&&(n.push(this.getDependency("node",w)),r.push(this.getDependency("accessor",g)),o.push(this.getDependency("accessor",m)),a.push(h),l.push(f))}return Promise.all([Promise.all(n),Promise.all(r),Promise.all(o),Promise.all(a),Promise.all(l)]).then(function(c){const d=c[0],u=c[1],h=c[2],f=c[3],w=c[4],g=[];for(let m=0,p=d.length;m<p;m++){const x=d[m],v=u[m],y=h[m],b=f[m],S=w[m];if(x===void 0)continue;x.updateMatrix();let A;switch(Re[S.path]){case Re.weights:A=Wr;break;case Re.rotation:A=Xn;break;case Re.position:case Re.scale:default:A=Kr;break}const _=x.name?x.name:x.uuid,E=b.interpolation!==void 0?Ho[b.interpolation]:js,M=[];Re[S.path]===Re.weights?x.traverse(function(C){C.morphTargetInfluences&&M.push(C.name?C.name:C.uuid)}):M.push(_);let R=y.array;if(y.normalized){const C=bn(R.constructor),L=new Float32Array(R.length);for(let B=0,F=R.length;B<F;B++)L[B]=R[B]*C;R=L}for(let C=0,L=M.length;C<L;C++){const B=new A(M[C]+"."+Re[S.path],v.array,R,E);b.interpolation==="CUBICSPLINE"&&(B.createInterpolant=function(F){const D=this instanceof Xn?Do:Ws;return new D(this.times,this.values,this.getValueSize()/3,F)},B.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),g.push(B)}}return new qr(s,void 0,g)})}createNodeMesh(e){const t=this.json,s=this,n=t.nodes[e];return n.mesh===void 0?null:s.getDependency("mesh",n.mesh).then(function(r){const o=s._getNodeRef(s.meshCache,n.mesh,r);return n.weights!==void 0&&o.traverse(function(a){if(a.isMesh)for(let l=0,c=n.weights.length;l<c;l++)a.morphTargetInfluences[l]=n.weights[l]}),o})}loadNode(e){const t=this.json,s=this,n=t.nodes[e],r=s._loadNodeShallow(e),o=[],a=n.children||[];for(let c=0,d=a.length;c<d;c++)o.push(s.getDependency("node",a[c]));const l=n.skin===void 0?Promise.resolve(null):s.getDependency("skin",n.skin);return Promise.all([r,Promise.all(o),l]).then(function(c){const d=c[0],u=c[1],h=c[2];h!==null&&d.traverse(function(f){f.isSkinnedMesh&&f.bind(h,Ko)});for(let f=0,w=u.length;f<w;f++)d.add(u[f]);return d})}_loadNodeShallow(e){const t=this.json,s=this.extensions,n=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const r=t.nodes[e],o=r.name?n.createUniqueName(r.name):"",a=[],l=n._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return l&&a.push(l),r.camera!==void 0&&a.push(n.getDependency("camera",r.camera).then(function(c){return n._getNodeRef(n.cameraCache,r.camera,c)})),n._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){a.push(c)}),this.nodeCache[e]=Promise.all(a).then(function(c){let d;if(r.isBone===!0?d=new Xr:c.length>1?d=new He:c.length===1?d=c[0]:d=new Nn,d!==c[0])for(let u=0,h=c.length;u<h;u++)d.add(c[u]);if(r.name&&(d.userData.name=r.name,d.name=o),Ie(d,r),r.extensions&&Fe(s,d,r),r.matrix!==void 0){const u=new Q;u.fromArray(r.matrix),d.applyMatrix4(u)}else r.translation!==void 0&&d.position.fromArray(r.translation),r.rotation!==void 0&&d.quaternion.fromArray(r.rotation),r.scale!==void 0&&d.scale.fromArray(r.scale);return n.associations.has(d)||n.associations.set(d,{}),n.associations.get(d).nodes=e,d}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],n=this,r=new He;s.name&&(r.name=n.createUniqueName(s.name)),Ie(r,s),s.extensions&&Fe(t,r,s);const o=s.nodes||[],a=[];for(let l=0,c=o.length;l<c;l++)a.push(n.getDependency("node",o[l]));return Promise.all(a).then(function(l){for(let d=0,u=l.length;d<u;d++)r.add(l[d]);const c=d=>{const u=new Map;for(const[h,f]of n.associations)(h instanceof Yt||h instanceof qn)&&u.set(h,f);return d.traverse(h=>{const f=n.associations.get(h);f!=null&&u.set(h,f)}),u};return n.associations=c(r),r})}}function $o(i,e,t){const s=e.attributes,n=new $;if(s.POSITION!==void 0){const a=t.json.accessors[s.POSITION],l=a.min,c=a.max;if(l!==void 0&&c!==void 0){if(n.set(new P(l[0],l[1],l[2]),new P(c[0],c[1],c[2])),a.normalized){const d=bn(st[a.componentType]);n.min.multiplyScalar(d),n.max.multiplyScalar(d)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const a=new P,l=new P;for(let c=0,d=r.length;c<d;c++){const u=r[c];if(u.POSITION!==void 0){const h=t.json.accessors[u.POSITION],f=h.min,w=h.max;if(f!==void 0&&w!==void 0){if(l.setX(Math.max(Math.abs(f[0]),Math.abs(w[0]))),l.setY(Math.max(Math.abs(f[1]),Math.abs(w[1]))),l.setZ(Math.max(Math.abs(f[2]),Math.abs(w[2]))),h.normalized){const g=bn(st[h.componentType]);l.multiplyScalar(g)}a.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(a)}i.boundingBox=n;const o=new ot;n.getCenter(o.center),o.radius=n.min.distanceTo(n.max)/2,i.boundingSphere=o}function ts(i,e,t){const s=e.attributes,n=[];function r(o,a){return t.getDependency("accessor",o).then(function(l){i.setAttribute(a,l)})}for(const o in s){const a=An[o]||o.toLowerCase();a in i.attributes||n.push(r(s[o],a))}if(e.indices!==void 0&&!i.index){const o=t.getDependency("accessor",e.indices).then(function(a){i.setIndex(a)});n.push(o)}return Ie(i,e),$o(i,e,t),Promise.all(n).then(function(){return e.targets!==void 0?Vo(i,e.targets,t):i})}var Yo=Object.defineProperty,Zo=(i,e,t)=>e in i?Yo(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,V=(i,e,t)=>(Zo(i,typeof e!="symbol"?e+"":e,t),t);const q={ComponentState:{DEFAULT:"default",TOUCHED:"touched",PRESSED:"pressed"},ComponentProperty:{BUTTON:"button",X_AXIS:"xAxis",Y_AXIS:"yAxis",STATE:"state"},ComponentType:{TOUCHPAD:"touchpad"},ButtonTouchThreshold:.05,AxisTouchThreshold:.1,VisualResponseProperty:{TRANSFORM:"transform",VISIBILITY:"visibility"}};async function $s(i){const e=await fetch(i);if(e.ok)return e.json();throw new Error(e.statusText)}async function Qo(i){if(!i)throw new Error("No basePath supplied");return await $s(`${i}/profilesList.json`)}async function Jo(i,e,t=null,s=!0){if(!i)throw new Error("No xrInputSource supplied");if(!e)throw new Error("No basePath supplied");const n=await Qo(e);let r;if(i.profiles.some(l=>{const c=n[l];return c&&(r={profileId:l,profilePath:`${e}/${c.path}`,deprecated:!!c.deprecated}),!!r}),!r){if(!t)throw new Error("No matching profile name found");const l=n[t];if(!l)throw new Error(`No matching profile name found and default profile "${t}" missing.`);r={profileId:t,profilePath:`${e}/${l.path}`,deprecated:!!l.deprecated}}const o=await $s(r.profilePath);let a;if(s){let l;if(i.handedness==="any"?l=o.layouts[Object.keys(o.layouts)[0]]:l=o.layouts[i.handedness],!l)throw new Error(`No matching handedness, ${i.handedness}, in profile ${r.profileId}`);l.assetPath&&(a=r.profilePath.replace("profile.json",l.assetPath))}return{profile:o,assetPath:a}}const ei={xAxis:0,yAxis:0,button:0,state:q.ComponentState.DEFAULT};function ti(i=0,e=0){let t=i,s=e;if(Math.sqrt(i*i+e*e)>1){const n=Math.atan2(e,i);t=Math.cos(n),s=Math.sin(n)}return{normalizedXAxis:t*.5+.5,normalizedYAxis:s*.5+.5}}class ni{constructor(e){V(this,"value"),V(this,"componentProperty"),V(this,"states"),V(this,"valueNodeName"),V(this,"valueNodeProperty"),V(this,"minNodeName"),V(this,"maxNodeName"),V(this,"valueNode"),V(this,"minNode"),V(this,"maxNode"),this.componentProperty=e.componentProperty,this.states=e.states,this.valueNodeName=e.valueNodeName,this.valueNodeProperty=e.valueNodeProperty,this.valueNodeProperty===q.VisualResponseProperty.TRANSFORM&&(this.minNodeName=e.minNodeName,this.maxNodeName=e.maxNodeName),this.value=0,this.updateFromComponent(ei)}updateFromComponent({xAxis:e,yAxis:t,button:s,state:n}){const{normalizedXAxis:r,normalizedYAxis:o}=ti(e,t);switch(this.componentProperty){case q.ComponentProperty.X_AXIS:this.value=this.states.includes(n)?r:.5;break;case q.ComponentProperty.Y_AXIS:this.value=this.states.includes(n)?o:.5;break;case q.ComponentProperty.BUTTON:this.value=this.states.includes(n)&&s?s:0;break;case q.ComponentProperty.STATE:this.valueNodeProperty===q.VisualResponseProperty.VISIBILITY?this.value=this.states.includes(n):this.value=this.states.includes(n)?1:0;break;default:throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`)}}}class si{constructor(e,t){if(V(this,"id"),V(this,"values"),V(this,"type"),V(this,"gamepadIndices"),V(this,"rootNodeName"),V(this,"visualResponses"),V(this,"touchPointNodeName"),V(this,"touchPointNode"),!e||!t||!t.visualResponses||!t.gamepadIndices||Object.keys(t.gamepadIndices).length===0)throw new Error("Invalid arguments supplied");this.id=e,this.type=t.type,this.rootNodeName=t.rootNodeName,this.touchPointNodeName=t.touchPointNodeName,this.visualResponses={},Object.keys(t.visualResponses).forEach(s=>{const n=new ni(t.visualResponses[s]);this.visualResponses[s]=n}),this.gamepadIndices=Object.assign({},t.gamepadIndices),this.values={state:q.ComponentState.DEFAULT,button:this.gamepadIndices.button!==void 0?0:void 0,xAxis:this.gamepadIndices.xAxis!==void 0?0:void 0,yAxis:this.gamepadIndices.yAxis!==void 0?0:void 0}}get data(){return{id:this.id,...this.values}}updateFromGamepad(e){if(this.values.state=q.ComponentState.DEFAULT,this.gamepadIndices.button!==void 0&&e.buttons.length>this.gamepadIndices.button){const t=e.buttons[this.gamepadIndices.button];this.values.button=t.value,this.values.button=this.values.button<0?0:this.values.button,this.values.button=this.values.button>1?1:this.values.button,t.pressed||this.values.button===1?this.values.state=q.ComponentState.PRESSED:(t.touched||this.values.button>q.ButtonTouchThreshold)&&(this.values.state=q.ComponentState.TOUCHED)}this.gamepadIndices.xAxis!==void 0&&e.axes.length>this.gamepadIndices.xAxis&&(this.values.xAxis=e.axes[this.gamepadIndices.xAxis],this.values.xAxis=this.values.xAxis<-1?-1:this.values.xAxis,this.values.xAxis=this.values.xAxis>1?1:this.values.xAxis,this.values.state===q.ComponentState.DEFAULT&&Math.abs(this.values.xAxis)>q.AxisTouchThreshold&&(this.values.state=q.ComponentState.TOUCHED)),this.gamepadIndices.yAxis!==void 0&&e.axes.length>this.gamepadIndices.yAxis&&(this.values.yAxis=e.axes[this.gamepadIndices.yAxis],this.values.yAxis=this.values.yAxis<-1?-1:this.values.yAxis,this.values.yAxis=this.values.yAxis>1?1:this.values.yAxis,this.values.state===q.ComponentState.DEFAULT&&Math.abs(this.values.yAxis)>q.AxisTouchThreshold&&(this.values.state=q.ComponentState.TOUCHED)),Object.values(this.visualResponses).forEach(t=>{t.updateFromComponent(this.values)})}}class ri{constructor(e,t,s){if(V(this,"xrInputSource"),V(this,"assetUrl"),V(this,"layoutDescription"),V(this,"id"),V(this,"components"),!e)throw new Error("No xrInputSource supplied");if(!t)throw new Error("No profile supplied");if(!t.layouts[e.handedness])throw new Error("No layout for "+e.handedness+" handedness");this.xrInputSource=e,this.assetUrl=s,this.id=t.profileId,this.layoutDescription=t.layouts[e.handedness],this.components={},Object.keys(this.layoutDescription.components).forEach(n=>{const r=this.layoutDescription.components[n];this.components[n]=new si(n,r)}),this.updateFromGamepad()}get gripSpace(){return this.xrInputSource.gripSpace}get targetRaySpace(){return this.xrInputSource.targetRaySpace}get data(){const e=[];return Object.values(this.components).forEach(t=>{e.push(t.data)}),e}updateFromGamepad(){Object.values(this.components).forEach(e=>{e.updateFromGamepad(this.xrInputSource.gamepad)})}}const ns=new $,Et=new P;class Un extends vr{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";const e=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],t=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],s=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(s),this.setAttribute("position",new Gn(e,3)),this.setAttribute("uv",new Gn(t,2))}applyMatrix4(e){const t=this.attributes.instanceStart,s=this.attributes.instanceEnd;return t!==void 0&&(t.applyMatrix4(e),s.applyMatrix4(e),t.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const s=new gn(t,6,1);return this.setAttribute("instanceStart",new De(s,3,0)),this.setAttribute("instanceEnd",new De(s,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(e,t=3){let s;e instanceof Float32Array?s=e:Array.isArray(e)&&(s=new Float32Array(e));const n=new gn(s,t*2,1);return this.setAttribute("instanceColorStart",new De(n,t,0)),this.setAttribute("instanceColorEnd",new De(n,t,t)),this}fromWireframeGeometry(e){return this.setPositions(e.attributes.position.array),this}fromEdgesGeometry(e){return this.setPositions(e.attributes.position.array),this}fromMesh(e){return this.fromWireframeGeometry(new yr(e.geometry)),this}fromLineSegments(e){const t=e.geometry;return this.setPositions(t.attributes.position.array),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new $);const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;e!==void 0&&t!==void 0&&(this.boundingBox.setFromBufferAttribute(e),ns.setFromBufferAttribute(t),this.boundingBox.union(ns))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ot),this.boundingBox===null&&this.computeBoundingBox();const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;if(e!==void 0&&t!==void 0){const s=this.boundingSphere.center;this.boundingBox.getCenter(s);let n=0;for(let r=0,o=e.count;r<o;r++)Et.fromBufferAttribute(e,r),n=Math.max(n,s.distanceToSquared(Et)),Et.fromBufferAttribute(t,r),n=Math.max(n,s.distanceToSquared(Et));this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(e){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(e)}}class Ys extends Un{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(e){const t=e.length-3,s=new Float32Array(2*t);for(let n=0;n<t;n+=3)s[2*n]=e[n],s[2*n+1]=e[n+1],s[2*n+2]=e[n+2],s[2*n+3]=e[n+3],s[2*n+4]=e[n+4],s[2*n+5]=e[n+5];return super.setPositions(s),this}setColors(e,t=3){const s=e.length-t,n=new Float32Array(2*s);if(t===3)for(let r=0;r<s;r+=t)n[2*r]=e[r],n[2*r+1]=e[r+1],n[2*r+2]=e[r+2],n[2*r+3]=e[r+3],n[2*r+4]=e[r+4],n[2*r+5]=e[r+5];else for(let r=0;r<s;r+=t)n[2*r]=e[r],n[2*r+1]=e[r+1],n[2*r+2]=e[r+2],n[2*r+3]=e[r+3],n[2*r+4]=e[r+4],n[2*r+5]=e[r+5],n[2*r+6]=e[r+6],n[2*r+7]=e[r+7];return super.setColors(n,t),this}fromLine(e){const t=e.geometry;return this.setPositions(t.attributes.position.array),this}}class Fn extends xr{constructor(e){super({type:"LineMaterial",uniforms:xn.clone(xn.merge([Vn.common,Vn.fog,{worldUnits:{value:1},linewidth:{value:1},resolution:{value:new k(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}}])),vertexShader:`
				#include <common>
				#include <fog_pars_vertex>
				#include <logdepthbuf_pars_vertex>
				#include <clipping_planes_pars_vertex>

				uniform float linewidth;
				uniform vec2 resolution;

				attribute vec3 instanceStart;
				attribute vec3 instanceEnd;

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
						attribute vec4 instanceColorStart;
						attribute vec4 instanceColorEnd;
					#else
						varying vec3 vLineColor;
						attribute vec3 instanceColorStart;
						attribute vec3 instanceColorEnd;
					#endif
				#endif

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#ifdef USE_DASH

					uniform float dashScale;
					attribute float instanceDistanceStart;
					attribute float instanceDistanceEnd;
					varying float vLineDistance;

				#endif

				void trimSegment( const in vec4 start, inout vec4 end ) {

					// trim end segment so it terminates between the camera plane and the near plane

					// conservative estimate of the near plane
					float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
					float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
					float nearEstimate = - 0.5 * b / a;

					float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

					end.xyz = mix( start.xyz, end.xyz, alpha );

				}

				void main() {

					#ifdef USE_COLOR

						vLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

					#endif

					#ifdef USE_DASH

						vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
						vUv = uv;

					#endif

					float aspect = resolution.x / resolution.y;

					// camera space
					vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
					vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

					#ifdef WORLD_UNITS

						worldStart = start.xyz;
						worldEnd = end.xyz;

					#else

						vUv = uv;

					#endif

					// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
					// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
					// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
					// perhaps there is a more elegant solution -- WestLangley

					bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

					if ( perspective ) {

						if ( start.z < 0.0 && end.z >= 0.0 ) {

							trimSegment( start, end );

						} else if ( end.z < 0.0 && start.z >= 0.0 ) {

							trimSegment( end, start );

						}

					}

					// clip space
					vec4 clipStart = projectionMatrix * start;
					vec4 clipEnd = projectionMatrix * end;

					// ndc space
					vec3 ndcStart = clipStart.xyz / clipStart.w;
					vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

					// direction
					vec2 dir = ndcEnd.xy - ndcStart.xy;

					// account for clip-space aspect ratio
					dir.x *= aspect;
					dir = normalize( dir );

					#ifdef WORLD_UNITS

						// get the offset direction as perpendicular to the view vector
						vec3 worldDir = normalize( end.xyz - start.xyz );
						vec3 offset;
						if ( position.y < 0.5 ) {

							offset = normalize( cross( start.xyz, worldDir ) );

						} else {

							offset = normalize( cross( end.xyz, worldDir ) );

						}

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

						// don't extend the line if we're rendering dashes because we
						// won't be rendering the endcaps
						#ifndef USE_DASH

							// extend the line bounds to encompass  endcaps
							start.xyz += - worldDir * linewidth * 0.5;
							end.xyz += worldDir * linewidth * 0.5;

							// shift the position of the quad so it hugs the forward edge of the line
							offset.xy -= dir * forwardOffset;
							offset.z += 0.5;

						#endif

						// endcaps
						if ( position.y > 1.0 || position.y < 0.0 ) {

							offset.xy += dir * 2.0 * forwardOffset;

						}

						// adjust for linewidth
						offset *= linewidth * 0.5;

						// set the world position
						worldPos = ( position.y < 0.5 ) ? start : end;
						worldPos.xyz += offset;

						// project the worldpos
						vec4 clip = projectionMatrix * worldPos;

						// shift the depth of the projected points so the line
						// segments overlap neatly
						vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
						clip.z = clipPose.z * clip.w;

					#else

						vec2 offset = vec2( dir.y, - dir.x );
						// undo aspect ratio adjustment
						dir.x /= aspect;
						offset.x /= aspect;

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						// endcaps
						if ( position.y < 0.0 ) {

							offset += - dir;

						} else if ( position.y > 1.0 ) {

							offset += dir;

						}

						// adjust for linewidth
						offset *= linewidth;

						// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
						offset /= resolution.y;

						// select end
						vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

						// back to clip space
						offset *= clip.w;

						clip.xy += offset;

					#endif

					gl_Position = clip;

					vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

					#include <logdepthbuf_vertex>
					#include <clipping_planes_vertex>
					#include <fog_vertex>

				}
			`,fragmentShader:`
				uniform vec3 diffuse;
				uniform float opacity;
				uniform float linewidth;

				#ifdef USE_DASH

					uniform float dashOffset;
					uniform float dashSize;
					uniform float gapSize;

				#endif

				varying float vLineDistance;

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#include <common>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <clipping_planes_pars_fragment>

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
					#else
						varying vec3 vLineColor;
					#endif
				#endif

				vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

					float mua;
					float mub;

					vec3 p13 = p1 - p3;
					vec3 p43 = p4 - p3;

					vec3 p21 = p2 - p1;

					float d1343 = dot( p13, p43 );
					float d4321 = dot( p43, p21 );
					float d1321 = dot( p13, p21 );
					float d4343 = dot( p43, p43 );
					float d2121 = dot( p21, p21 );

					float denom = d2121 * d4343 - d4321 * d4321;

					float numer = d1343 * d4321 - d1321 * d4343;

					mua = numer / denom;
					mua = clamp( mua, 0.0, 1.0 );
					mub = ( d1343 + d4321 * ( mua ) ) / d4343;
					mub = clamp( mub, 0.0, 1.0 );

					return vec2( mua, mub );

				}

				void main() {

					#include <clipping_planes_fragment>

					#ifdef USE_DASH

						if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

						if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

					#endif

					float alpha = opacity;

					#ifdef WORLD_UNITS

						// Find the closest points on the view ray and the line segment
						vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
						vec3 lineDir = worldEnd - worldStart;
						vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

						vec3 p1 = worldStart + lineDir * params.x;
						vec3 p2 = rayEnd * params.y;
						vec3 delta = p1 - p2;
						float len = length( delta );
						float norm = len / linewidth;

						#ifndef USE_DASH

							#ifdef USE_ALPHA_TO_COVERAGE

								float dnorm = fwidth( norm );
								alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

							#else

								if ( norm > 0.5 ) {

									discard;

								}

							#endif

						#endif

					#else

						#ifdef USE_ALPHA_TO_COVERAGE

							// artifacts appear on some hardware if a derivative is taken within a conditional
							float a = vUv.x;
							float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
							float len2 = a * a + b * b;
							float dlen = fwidth( len2 );

							if ( abs( vUv.y ) > 1.0 ) {

								alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

							}

						#else

							if ( abs( vUv.y ) > 1.0 ) {

								float a = vUv.x;
								float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
								float len2 = a * a + b * b;

								if ( len2 > 1.0 ) discard;

							}

						#endif

					#endif

					vec4 diffuseColor = vec4( diffuse, alpha );
					#ifdef USE_COLOR
						#ifdef USE_LINE_COLOR_ALPHA
							diffuseColor *= vLineColor;
						#else
							diffuseColor.rgb *= vLineColor;
						#endif
					#endif

					#include <logdepthbuf_fragment>

					gl_FragColor = diffuseColor;

					#include <tonemapping_fragment>
					#include <${parseInt(Os.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>
					#include <fog_fragment>
					#include <premultiplied_alpha_fragment>

				}
			`,clipping:!0}),this.isLineMaterial=!0,this.onBeforeCompile=function(){this.transparent?this.defines.USE_LINE_COLOR_ALPHA="1":delete this.defines.USE_LINE_COLOR_ALPHA},Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},worldUnits:{enumerable:!0,get:function(){return"WORLD_UNITS"in this.defines},set:function(t){t===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashed:{enumerable:!0,get:function(){return"USE_DASH"in this.defines},set(t){!!t!="USE_DASH"in this.defines&&(this.needsUpdate=!0),t===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}},alphaToCoverage:{enumerable:!0,get:function(){return"USE_ALPHA_TO_COVERAGE"in this.defines},set:function(t){!!t!="USE_ALPHA_TO_COVERAGE"in this.defines&&(this.needsUpdate=!0),t===!0?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1)}}}),this.setValues(e)}}const ss=new P,rs=new P,ee=new bt,te=new bt,we=new bt,en=new P,tn=new Q,ne=new _e,os=new P,Mt=new $,Pt=new ot,Ae=new bt;let be,Sn,Zs,Ge;function is(i,e,t){return Ae.set(0,0,-e,1).applyMatrix4(i.projectionMatrix),Ae.multiplyScalar(1/Ae.w),Ae.x=Ge/t.width,Ae.y=Ge/t.height,Ae.applyMatrix4(i.projectionMatrixInverse),Ae.multiplyScalar(1/Ae.w),Math.abs(Math.max(Ae.x,Ae.y))}function oi(i,e){for(let t=0,s=Sn.count;t<s;t++){ne.start.fromBufferAttribute(Sn,t),ne.end.fromBufferAttribute(Zs,t);const n=new P,r=new P;be.distanceSqToSegment(ne.start,ne.end,r,n),r.distanceTo(n)<Ge*.5&&e.push({point:r,pointOnLine:n,distance:be.origin.distanceTo(r),object:i,face:null,faceIndex:t,uv:null,uv2:null})}}function ii(i,e,t){const s=e.projectionMatrix,n=i.material.resolution,r=i.matrixWorld,o=i.geometry,a=o.attributes.instanceStart,l=o.attributes.instanceEnd,c=-e.near;be.at(1,we),we.w=1,we.applyMatrix4(e.matrixWorldInverse),we.applyMatrix4(s),we.multiplyScalar(1/we.w),we.x*=n.x/2,we.y*=n.y/2,we.z=0,en.copy(we),tn.multiplyMatrices(e.matrixWorldInverse,r);for(let d=0,u=a.count;d<u;d++){if(ee.fromBufferAttribute(a,d),te.fromBufferAttribute(l,d),ee.w=1,te.w=1,ee.applyMatrix4(tn),te.applyMatrix4(tn),ee.z>c&&te.z>c)continue;if(ee.z>c){const m=ee.z-te.z,p=(ee.z-c)/m;ee.lerp(te,p)}else if(te.z>c){const m=te.z-ee.z,p=(te.z-c)/m;te.lerp(ee,p)}ee.applyMatrix4(s),te.applyMatrix4(s),ee.multiplyScalar(1/ee.w),te.multiplyScalar(1/te.w),ee.x*=n.x/2,ee.y*=n.y/2,te.x*=n.x/2,te.y*=n.y/2,ne.start.copy(ee),ne.start.z=0,ne.end.copy(te),ne.end.z=0;const h=ne.closestPointToPointParameter(en,!0);ne.at(h,os);const f=Fs.lerp(ee.z,te.z,h),w=f>=-1&&f<=1,g=en.distanceTo(os)<Ge*.5;if(w&&g){ne.start.fromBufferAttribute(a,d),ne.end.fromBufferAttribute(l,d),ne.start.applyMatrix4(r),ne.end.applyMatrix4(r);const m=new P,p=new P;be.distanceSqToSegment(ne.start,ne.end,p,m),t.push({point:p,pointOnLine:m,distance:be.origin.distanceTo(p),object:i,face:null,faceIndex:d,uv:null,uv2:null})}}}class Qs extends Ne{constructor(e=new Un,t=new Fn({color:Math.random()*16777215})){super(e,t),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const e=this.geometry,t=e.attributes.instanceStart,s=e.attributes.instanceEnd,n=new Float32Array(2*t.count);for(let o=0,a=0,l=t.count;o<l;o++,a+=2)ss.fromBufferAttribute(t,o),rs.fromBufferAttribute(s,o),n[a]=a===0?0:n[a-1],n[a+1]=n[a]+ss.distanceTo(rs);const r=new gn(n,2,1);return e.setAttribute("instanceDistanceStart",new De(r,1,0)),e.setAttribute("instanceDistanceEnd",new De(r,1,1)),this}raycast(e,t){const s=this.material.worldUnits,n=e.camera;n===null&&!s&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const r=e.params.Line2!==void 0&&e.params.Line2.threshold||0;be=e.ray;const o=this.matrixWorld,a=this.geometry,l=this.material;Ge=l.linewidth+r,Sn=a.attributes.instanceStart,Zs=a.attributes.instanceEnd,a.boundingSphere===null&&a.computeBoundingSphere(),Pt.copy(a.boundingSphere).applyMatrix4(o);let c;if(s)c=Ge*.5;else{const u=Math.max(n.near,Pt.distanceToPoint(be.origin));c=is(n,u,l.resolution)}if(Pt.radius+=c,be.intersectsSphere(Pt)===!1)return;a.boundingBox===null&&a.computeBoundingBox(),Mt.copy(a.boundingBox).applyMatrix4(o);let d;if(s)d=Ge*.5;else{const u=Math.max(n.near,Mt.distanceToPoint(be.origin));d=is(n,u,l.resolution)}Mt.expandByScalar(d),be.intersectsBox(Mt)!==!1&&(s?oi(this,t):ii(this,n,t))}}class ai extends Qs{constructor(e=new Ys,t=new Fn({color:Math.random()*16777215})){super(e,t),this.isLine2=!0,this.type="Line2"}}const li="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles",ci="generic-trigger";class ui{constructor(e=null,t=li){this.gltfLoader=e??new Xs,this.path=t,this._assetCache={}}initializeControllerModel(e,t){return t.targetRayMode!=="tracked-pointer"||!t.gamepad?Promise.resolve():Jo(t,this.path,ci).then(({profile:s,assetPath:n})=>{if(!n)throw new Error("no asset path");const r=new ri(t,s,n);e.connectMotionController(r);const o=r.assetUrl,a=this._assetCache[o];if(a){const l=a.scene.clone();e.connectModel(l)}else{if(!this.gltfLoader)throw new Error("GLTFLoader not set.");this.gltfLoader.setPath(""),this.gltfLoader.load(o,l=>{if(!e.motionController){console.warn("motionController gone while gltf load, bailing...");return}this._assetCache[o]=l;const c=l.scene.clone();e.connectModel(c)},void 0,()=>{throw new Error(`Asset ${o} missing or malformed.`)})}}).catch(s=>{console.warn(s)})}}const as=i=>"envMap"in i,ls=(i,e)=>{i.envMap=e,i.needsUpdate=!0},Js=(i,e)=>{e instanceof Ne&&(Array.isArray(e.material)?e.material.forEach(t=>as(t)?ls(t,i):void 0):as(e.material)&&ls(e.material,i))},cs=i=>"envMapIntensity"in i,us=(i,e)=>{i.envMapIntensity=e,i.needsUpdate=!0},_n=(i,e)=>{e instanceof Ne&&(Array.isArray(e.material)?e.material.forEach(t=>cs(t)?us(t,i):void 0):cs(e.material)&&us(e.material,i))};function di(i,e){Object.values(i.components).forEach(t=>{const{type:s,touchPointNodeName:n,visualResponses:r}=t;if(s===q.ComponentType.TOUCHPAD&&n)if(t.touchPointNode=e.getObjectByName(n),t.touchPointNode){const o=new Qr(.001),a=new je({color:255}),l=new Ne(o,a);t.touchPointNode.add(l)}else console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);Object.values(r).forEach(o=>{const{valueNodeName:a,minNodeName:l,maxNodeName:c,valueNodeProperty:d}=o;if(d===q.VisualResponseProperty.TRANSFORM&&l&&c){if(o.minNode=e.getObjectByName(l),o.maxNode=e.getObjectByName(c),!o.minNode){console.warn(`Could not find ${l} in the model`);return}if(!o.maxNode){console.warn(`Could not find ${c} in the model`);return}}o.valueNode=e.getObjectByName(a),o.valueNode||console.warn(`Could not find ${a} in the model`)})})}function hi(i,e){di(i.motionController,e),(i.envMap||i.envMapIntensity!=null)&&e.traverse(t=>{i.envMap&&Js(i.envMap,t),i.envMapIntensity!=null&&_n(i.envMapIntensity,t)}),i.add(e)}class fi extends He{constructor(){super(),this.motionController=null,this.envMap=null,this.envMapIntensity=1,this.scene=null}setEnvironmentMap(e,t=1){var s;return this.envMap===e&&this.envMapIntensity===t?this:(this.envMap=e,this.envMapIntensity=t,(s=this.scene)==null||s.traverse(n=>{Js(e,n),_n(t,n)}),this)}setEnvironmentMapIntensity(e){var t;return this.envMapIntensity===e?this:(this.envMapIntensity=e,(t=this.scene)==null||t.traverse(s=>_n(e,s)),this)}connectModel(e){if(!this.motionController){console.warn("scene tried to add, but no motion controller");return}this.scene=e,hi(this,e),this.dispatchEvent({type:"modelconnected",data:e})}connectMotionController(e){this.motionController=e,this.dispatchEvent({type:"motionconnected",data:e})}updateMatrixWorld(e){super.updateMatrixWorld(e),this.motionController&&(this.motionController.updateFromGamepad(),Object.values(this.motionController.components).forEach(t=>{Object.values(t.visualResponses).forEach(s=>{const{valueNode:n,minNode:r,maxNode:o,value:a,valueNodeProperty:l}=s;n&&(l===q.VisualResponseProperty.VISIBILITY&&typeof a=="boolean"?n.visible=a:l===q.VisualResponseProperty.TRANSFORM&&r&&o&&typeof a=="number"&&(n.quaternion.slerpQuaternions(r.quaternion,o.quaternion,a),n.position.lerpVectors(r.position,o.position,a)))})}))}disconnect(){this.dispatchEvent({type:"motiondisconnected",data:this.motionController}),this.dispatchEvent({type:"modeldisconnected",data:this.scene}),this.motionController=null,this.scene&&this.remove(this.scene),this.scene=null}dispose(){this.disconnect()}}const pi=T.forwardRef(function({target:i,hideOnBlur:e=!1,...t},s){const n=X(a=>a.hoverState),r=T.useRef(null),o=T.useMemo(()=>new Is().setFromPoints([new P(0,0,0),new P(0,0,-1)]),[]);return T.useImperativeHandle(s,()=>r.current),it(()=>{if(!i.inputSource)return;let a=1;const l=n[i.inputSource.handedness].values().next().value;l&&i.inputSource.handedness!=="none"?(a=l.distance,e&&(r.current.visible=!1)):e&&(r.current.visible=!0);const c=-.01;r.current.scale.z=a+c}),T.createElement("line",{ref:r,geometry:o,"material-opacity":.8,"material-transparent":!0,...t})}),mi=new ui,gi=({target:i,envMap:e,envMapIntensity:t})=>{const s=T.useRef(null),n=Se(l=>{e!=null&&l.setEnvironmentMap(e)}),r=Se(l=>l.setEnvironmentMap(null)),o=Se(l=>{t!=null&&l.setEnvironmentMapIntensity(t)}),a=T.useCallback(l=>{var c,d,u;if(s.current=l,l){if(i.xrControllerModel=l,(c=i.inputSource)!=null&&c.hand)return;n.current(l),o.current(l),i.inputSource?mi.initializeControllerModel(l,i.inputSource):console.warn("no input source on XRController when handleControllerModel")}else{if((d=i.inputSource)!=null&&d.hand)return;(u=i.xrControllerModel)==null||u.disconnect(),i.xrControllerModel=null}},[i,o,n]);return T.useLayoutEffect(()=>{s.current&&(e?n.current(s.current):r.current(s.current))},[e,n,r]),T.useLayoutEffect(()=>{s.current&&o.current(s.current)},[t,o]),T.createElement("xRControllerModel",{ref:a})};function xi({rayMaterial:i={},hideRaysOnBlur:e=!1,envMap:t,envMapIntensity:s}){const n=X(a=>a.controllers),r=X(a=>a.isHandTracking),o=T.useMemo(()=>Object.entries(i).reduce((a,[l,c])=>({...a,[`material-${l}`]:c}),{}),[JSON.stringify(i)]);return T.useMemo(()=>Vs({XRControllerModel:fi}),[]),T.createElement(T.Fragment,null,n.map((a,l)=>T.createElement(T.Fragment,{key:l},wn(T.createElement(gi,{target:a,envMap:t,envMapIntensity:s}),a.grip),wn(T.createElement(pi,{visible:!r,hideOnBlur:e,target:a,...o}),a.controller))))}const vi="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/";class yi{constructor(e,t,s=vi,n,r){this.controller=t,this.handModel=e,this.bones=[];const o=new Xs;r||o.setPath(s),o.load(r??`${n}.glb`,a=>{const l=a.scene.children[0];this.handModel.add(l),this.scene=l;const c=l.getObjectByProperty("type","SkinnedMesh");c.frustumCulled=!1,c.castShadow=!0,c.receiveShadow=!0,["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"].forEach(d=>{const u=l.getObjectByName(d);u!==void 0?u.jointName=d:console.warn(`Couldn't find ${d} in ${n} hand mesh`),this.bones.push(u)})})}updateMesh(){const e=this.controller.joints;let t=!0;for(let s=0;s<this.bones.length;s++){const n=this.bones[s];if(n){const r=e[n.jointName];if(r.visible){const o=r.position;n.position.copy(o),n.quaternion.copy(r.quaternion),t=!1}}}t&&this.scene?this.scene.visible=!1:this.scene&&(this.scene.visible=!0)}dispose(){this.scene&&this.handModel.remove(this.scene)}}const wi=.01,Ai="index-finger-tip";class bi extends Nn{constructor(e,t,s){super(),this._onConnected=n=>{const r=n.data;r.hand&&!this.motionController&&(this.xrInputSource=r,this.motionController=new yi(this,this.controller,void 0,r.handedness,r.handedness==="left"?this.leftModelPath:this.rightModelPath))},this._onDisconnected=()=>{var n;(n=this.xrInputSource)!=null&&n.hand&&this.motionControllerCleanup()},this.controller=e,this.motionController=null,this.envMap=null,this.leftModelPath=t,this.rightModelPath=s,this.mesh=null,this.xrInputSource=null,e.addEventListener("connected",this._onConnected),e.addEventListener("disconnected",this._onDisconnected)}motionControllerCleanup(){var e;this.clear(),(e=this.motionController)==null||e.dispose(),this.motionController=null}updateMatrixWorld(e){super.updateMatrixWorld(e),this.motionController&&this.motionController.updateMesh()}getPointerPosition(){const e=this.controller.joints[Ai];return e?e.position:null}intersectBoxObject(e){const t=this.getPointerPosition();if(t){const s=new ot(t,wi),n=new $().setFromObject(e);return s.intersectsBox(n)}else return!1}checkButton(e){this.intersectBoxObject(e)?e.onPress():e.onClear(),e.isPressed()&&e.whilePressed()}dispose(){this.motionControllerCleanup(),this.controller.removeEventListener("connected",this._onConnected),this.controller.removeEventListener("disconnected",this._onDisconnected)}}function Si({modelLeft:i,modelRight:e}){const t=X(s=>s.controllers);return T.useMemo(()=>Vs({OculusHandModel:bi}),[]),de(()=>{for(const s of t)s.hand.dispatchEvent({type:"connected",data:s.inputSource,fake:!0})},[t,i,e]),T.createElement(T.Fragment,null,t.map(({hand:s})=>wn(T.createElement("oculusHandModel",{args:[s,i,e]}),s)))}const _i=T.forwardRef(function({points:i,color:e=16777215,vertexColors:t,linewidth:s,lineWidth:n,segments:r,dashed:o,...a},l){var c;const d=Me(g=>g.size),u=T.useMemo(()=>r?new Qs:new ai,[r]),[h]=T.useState(()=>new Fn),f=(t==null||(c=t[0])==null?void 0:c.length)===4?4:3,w=T.useMemo(()=>{const g=r?new Un:new Ys,m=i.map(p=>{const x=Array.isArray(p);return p instanceof P||p instanceof bt?[p.x,p.y,p.z]:p instanceof k?[p.x,p.y,0]:x&&p.length===3?[p[0],p[1],p[2]]:x&&p.length===2?[p[0],p[1],0]:p});if(g.setPositions(m.flat()),t){e=16777215;const p=t.map(x=>x instanceof ze?x.toArray():x);g.setColors(p.flat(),f)}return g},[i,r,t,f]);return T.useLayoutEffect(()=>{u.computeLineDistances()},[i,u]),T.useLayoutEffect(()=>{o?h.defines.USE_DASH="":delete h.defines.USE_DASH,h.needsUpdate=!0},[o,h]),T.useEffect(()=>()=>w.dispose(),[w]),T.createElement("primitive",At({object:u,ref:l},a),T.createElement("primitive",{object:w,attach:"geometry"}),T.createElement("primitive",At({object:h,attach:"material",color:e,vertexColors:!!t,resolution:[d.width,d.height],linewidth:s??n,dashed:o,transparent:f===4},a)))}),er=T.forwardRef(({sdfGlyphSize:i=64,anchorX:e="center",anchorY:t="middle",font:s,fontSize:n=1,children:r,characters:o,onSync:a,...l},c)=>{const{Text:d,preloadFont:u}=Kn(async()=>Zr(()=>import("./troika-three-text.esm-Dv4dfK9D-CbbrrTSH.js"),__vite__mapDeps([0,1,2])),[]),h=Me(({invalidate:m})=>m),[f]=T.useState(()=>new d),[w,g]=T.useMemo(()=>{const m=[];let p="";return T.Children.forEach(r,x=>{typeof x=="string"||typeof x=="number"?p+=x:m.push(x)}),[m,p]},[r]);return Kn(()=>new Promise(m=>u({font:s,characters:o},m)),["troika-text",s,o]),T.useLayoutEffect(()=>void f.sync(()=>{h(),a&&a(f)})),T.useEffect(()=>()=>f.dispose(),[f]),T.createElement("primitive",At({object:f,ref:c,font:s,text:g,anchorX:e,anchorY:t,fontSize:n,sdfGlyphSize:i},l),w)}),tr=0,Ti=1,nr=2,ds=2,nn=1.25,hs=1,yt=32,Kt=65535,Ei=Math.pow(2,-24),sn=Symbol("SKIP_GENERATION");function Mi(i){return i.index?i.index.count:i.attributes.position.count}function at(i){return Mi(i)/3}function Pi(i,e=ArrayBuffer){return i>65535?new Uint32Array(new e(4*i)):new Uint16Array(new e(2*i))}function Ci(i,e){if(!i.index){const t=i.attributes.position.count,s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,n=Pi(t,s);i.setIndex(new vt(n,1));for(let r=0;r<t;r++)n[r]=r}}function sr(i){const e=at(i),t=i.drawRange,s=t.start/3,n=(t.start+t.count)/3,r=Math.max(0,s),o=Math.min(e,n)-r;return[{offset:Math.floor(r),count:Math.floor(o)}]}function rr(i){if(!i.groups||!i.groups.length)return sr(i);const e=[],t=new Set,s=i.drawRange,n=s.start/3,r=(s.start+s.count)/3;for(const a of i.groups){const l=a.start/3,c=(a.start+a.count)/3;t.add(Math.max(n,l)),t.add(Math.min(r,c))}const o=Array.from(t.values()).sort((a,l)=>a-l);for(let a=0;a<o.length-1;a++){const l=o[a],c=o[a+1];e.push({offset:Math.floor(l),count:Math.floor(c-l)})}return e}function Ri(i){if(i.groups.length===0)return!1;const e=at(i),t=rr(i).sort((r,o)=>r.offset-o.offset),s=t[t.length-1];s.count=Math.min(e-s.offset,s.count);let n=0;return t.forEach(({count:r})=>n+=r),e!==n}function rn(i,e,t,s,n){let r=1/0,o=1/0,a=1/0,l=-1/0,c=-1/0,d=-1/0,u=1/0,h=1/0,f=1/0,w=-1/0,g=-1/0,m=-1/0;for(let p=e*6,x=(e+t)*6;p<x;p+=6){const v=i[p+0],y=i[p+1],b=v-y,S=v+y;b<r&&(r=b),S>l&&(l=S),v<u&&(u=v),v>w&&(w=v);const A=i[p+2],_=i[p+3],E=A-_,M=A+_;E<o&&(o=E),M>c&&(c=M),A<h&&(h=A),A>g&&(g=A);const R=i[p+4],C=i[p+5],L=R-C,B=R+C;L<a&&(a=L),B>d&&(d=B),R<f&&(f=R),R>m&&(m=R)}s[0]=r,s[1]=o,s[2]=a,s[3]=l,s[4]=c,s[5]=d,n[0]=u,n[1]=h,n[2]=f,n[3]=w,n[4]=g,n[5]=m}function Li(i,e=null,t=null,s=null){const n=i.attributes.position,r=i.index?i.index.array:null,o=at(i),a=n.normalized;let l;e===null?(l=new Float32Array(o*6*4),t=0,s=o):(l=e,t=t||0,s=s||o);const c=n.array,d=n.offset||0;let u=3;n.isInterleavedBufferAttribute&&(u=n.data.stride);const h=["getX","getY","getZ"];for(let f=t;f<t+s;f++){const w=f*3,g=f*6;let m=w+0,p=w+1,x=w+2;r&&(m=r[m],p=r[p],x=r[x]),a||(m=m*u+d,p=p*u+d,x=x*u+d);for(let v=0;v<3;v++){let y,b,S;a?(y=n[h[v]](m),b=n[h[v]](p),S=n[h[v]](x)):(y=c[m+v],b=c[p+v],S=c[x+v]);let A=y;b<A&&(A=b),S<A&&(A=S);let _=y;b>_&&(_=b),S>_&&(_=S);const E=(_-A)/2,M=v*2;l[g+M+0]=A+E,l[g+M+1]=E+(Math.abs(A)+E)*Ei}}return l}function G(i,e,t){return t.min.x=e[i],t.min.y=e[i+1],t.min.z=e[i+2],t.max.x=e[i+3],t.max.y=e[i+4],t.max.z=e[i+5],t}function fs(i){let e=-1,t=-1/0;for(let s=0;s<3;s++){const n=i[s+3]-i[s];n>t&&(t=n,e=s)}return e}function ps(i,e){e.set(i)}function ms(i,e,t){let s,n;for(let r=0;r<3;r++){const o=r+3;s=i[r],n=e[r],t[r]=s<n?s:n,s=i[o],n=e[o],t[o]=s>n?s:n}}function Ct(i,e,t){for(let s=0;s<3;s++){const n=e[i+2*s],r=e[i+2*s+1],o=n-r,a=n+r;o<t[s]&&(t[s]=o),a>t[s+3]&&(t[s+3]=a)}}function ut(i){const e=i[3]-i[0],t=i[4]-i[1],s=i[5]-i[2];return 2*(e*t+t*s+s*e)}const Ee=32,Ii=(i,e)=>i.candidate-e.candidate,Le=new Array(Ee).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Rt=new Float32Array(6);function Bi(i,e,t,s,n,r){let o=-1,a=0;if(r===tr)o=fs(e),o!==-1&&(a=(e[o]+e[o+3])/2);else if(r===Ti)o=fs(i),o!==-1&&(a=Oi(t,s,n,o));else if(r===nr){const l=ut(i);let c=nn*n;const d=s*6,u=(s+n)*6;for(let h=0;h<3;h++){const f=e[h],w=(e[h+3]-f)/Ee;if(n<Ee/4){const g=[...Le];g.length=n;let m=0;for(let x=d;x<u;x+=6,m++){const v=g[m];v.candidate=t[x+2*h],v.count=0;const{bounds:y,leftCacheBounds:b,rightCacheBounds:S}=v;for(let A=0;A<3;A++)S[A]=1/0,S[A+3]=-1/0,b[A]=1/0,b[A+3]=-1/0,y[A]=1/0,y[A+3]=-1/0;Ct(x,t,y)}g.sort(Ii);let p=n;for(let x=0;x<p;x++){const v=g[x];for(;x+1<p&&g[x+1].candidate===v.candidate;)g.splice(x+1,1),p--}for(let x=d;x<u;x+=6){const v=t[x+2*h];for(let y=0;y<p;y++){const b=g[y];v>=b.candidate?Ct(x,t,b.rightCacheBounds):(Ct(x,t,b.leftCacheBounds),b.count++)}}for(let x=0;x<p;x++){const v=g[x],y=v.count,b=n-v.count,S=v.leftCacheBounds,A=v.rightCacheBounds;let _=0;y!==0&&(_=ut(S)/l);let E=0;b!==0&&(E=ut(A)/l);const M=hs+nn*(_*y+E*b);M<c&&(o=h,c=M,a=v.candidate)}}else{for(let p=0;p<Ee;p++){const x=Le[p];x.count=0,x.candidate=f+w+p*w;const v=x.bounds;for(let y=0;y<3;y++)v[y]=1/0,v[y+3]=-1/0}for(let p=d;p<u;p+=6){let x=~~((t[p+2*h]-f)/w);x>=Ee&&(x=Ee-1);const v=Le[x];v.count++,Ct(p,t,v.bounds)}const g=Le[Ee-1];ps(g.bounds,g.rightCacheBounds);for(let p=Ee-2;p>=0;p--){const x=Le[p],v=Le[p+1];ms(x.bounds,v.rightCacheBounds,x.rightCacheBounds)}let m=0;for(let p=0;p<Ee-1;p++){const x=Le[p],v=x.count,y=x.bounds,b=Le[p+1].rightCacheBounds;v!==0&&(m===0?ps(y,Rt):ms(y,Rt,Rt)),m+=v;let S=0,A=0;m!==0&&(S=ut(Rt)/l);const _=n-m;_!==0&&(A=ut(b)/l);const E=hs+nn*(S*m+A*_);E<c&&(o=h,c=E,a=x.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:o,pos:a}}function Oi(i,e,t,s){let n=0;for(let r=e,o=e+t;r<o;r++)n+=i[r*6+s*2];return n/t}class on{constructor(){this.boundingData=new Float32Array(6)}}function Ni(i,e,t,s,n,r){let o=s,a=s+n-1;const l=r.pos,c=r.axis*2;for(;;){for(;o<=a&&t[o*6+c]<l;)o++;for(;o<=a&&t[a*6+c]>=l;)a--;if(o<a){for(let d=0;d<3;d++){let u=e[o*3+d];e[o*3+d]=e[a*3+d],e[a*3+d]=u}for(let d=0;d<6;d++){let u=t[o*6+d];t[o*6+d]=t[a*6+d],t[a*6+d]=u}o++,a--}else return o}}function zi(i,e,t,s,n,r){let o=s,a=s+n-1;const l=r.pos,c=r.axis*2;for(;;){for(;o<=a&&t[o*6+c]<l;)o++;for(;o<=a&&t[a*6+c]>=l;)a--;if(o<a){let d=i[o];i[o]=i[a],i[a]=d;for(let u=0;u<6;u++){let h=t[o*6+u];t[o*6+u]=t[a*6+u],t[a*6+u]=h}o++,a--}else return o}}function oe(i,e){return e[i+15]===65535}function ie(i,e){return e[i+6]}function he(i,e){return e[i+14]}function fe(i){return i+8}function pe(i,e){return e[i+6]}function or(i,e){return e[i+7]}let ir,xt,Gt,ar;const Ui=Math.pow(2,32);function Tn(i){return"count"in i?1:1+Tn(i.left)+Tn(i.right)}function Fi(i,e,t){return ir=new Float32Array(t),xt=new Uint32Array(t),Gt=new Uint16Array(t),ar=new Uint8Array(t),En(i,e)}function En(i,e){const t=i/4,s=i/2,n="count"in e,r=e.boundingData;for(let o=0;o<6;o++)ir[t+o]=r[o];if(n)if(e.buffer){const o=e.buffer;ar.set(new Uint8Array(o),i);for(let a=i,l=i+o.byteLength;a<l;a+=yt){const c=a/2;oe(c,Gt)||(xt[a/4+6]+=t)}return i+o.byteLength}else{const o=e.offset,a=e.count;return xt[t+6]=o,Gt[s+14]=a,Gt[s+15]=Kt,i+yt}else{const o=e.left,a=e.right,l=e.splitAxis;let c;if(c=En(i+yt,o),c/4>Ui)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return xt[t+6]=c/4,c=En(c,a),xt[t+7]=l,c}}function ji(i,e){const t=(i.index?i.index.count:i.attributes.position.count)/3,s=t>2**16,n=s?4:2,r=e?new SharedArrayBuffer(t*n):new ArrayBuffer(t*n),o=s?new Uint32Array(r):new Uint16Array(r);for(let a=0,l=o.length;a<l;a++)o[a]=a;return o}function Di(i,e,t,s,n){const{maxDepth:r,verbose:o,maxLeafTris:a,strategy:l,onProgress:c,indirect:d}=n,u=i._indirectBuffer,h=i.geometry,f=h.index?h.index.array:null,w=d?zi:Ni,g=at(h),m=new Float32Array(6);let p=!1;const x=new on;return rn(e,t,s,x.boundingData,m),y(x,t,s,m),x;function v(b){c&&c(b/g)}function y(b,S,A,_=null,E=0){if(!p&&E>=r&&(p=!0,o&&(console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`),console.warn(h))),A<=a||E>=r)return v(S+A),b.offset=S,b.count=A,b;const M=Bi(b.boundingData,_,e,S,A,l);if(M.axis===-1)return v(S+A),b.offset=S,b.count=A,b;const R=w(u,f,e,S,A,M);if(R===S||R===S+A)v(S+A),b.offset=S,b.count=A;else{b.splitAxis=M.axis;const C=new on,L=S,B=R-S;b.left=C,rn(e,L,B,C.boundingData,m),y(C,L,B,m,E+1);const F=new on,D=R,Z=A-B;b.right=F,rn(e,D,Z,F.boundingData,m),y(F,D,Z,m,E+1)}return b}}function Hi(i,e){const t=i.geometry;e.indirect&&(i._indirectBuffer=ji(t,e.useSharedArrayBuffer),Ri(t)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),i._indirectBuffer||Ci(t,e);const s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,n=Li(t),r=e.indirect?sr(t):rr(t);i._roots=r.map(o=>{const a=Di(i,n,o.offset,o.count,e),l=Tn(a),c=new s(yt*l);return Fi(0,a,c),c})}class Pe{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let s=1/0,n=-1/0;for(let r=0,o=e.length;r<o;r++){const a=e[r][t];s=a<s?a:s,n=a>n?a:n}this.min=s,this.max=n}setFromPoints(e,t){let s=1/0,n=-1/0;for(let r=0,o=t.length;r<o;r++){const a=t[r],l=e.dot(a);s=l<s?l:s,n=l>n?l:n}this.min=s,this.max=n}isSeparated(e){return this.min>e.max||e.min>this.max}}Pe.prototype.setFromBox=(function(){const i=new P;return function(e,t){const s=t.min,n=t.max;let r=1/0,o=-1/0;for(let a=0;a<=1;a++)for(let l=0;l<=1;l++)for(let c=0;c<=1;c++){i.x=s.x*a+n.x*(1-a),i.y=s.y*l+n.y*(1-l),i.z=s.z*c+n.z*(1-c);const d=e.dot(i);r=Math.min(d,r),o=Math.max(d,o)}this.min=r,this.max=o}})();const ki=(function(){const i=new P,e=new P,t=new P;return function(s,n,r){const o=s.start,a=i,l=n.start,c=e;t.subVectors(o,l),i.subVectors(s.end,s.start),e.subVectors(n.end,n.start);const d=t.dot(c),u=c.dot(a),h=c.dot(c),f=t.dot(a),w=a.dot(a)*h-u*u;let g,m;w!==0?g=(d*u-f*h)/w:g=0,m=(d+g*u)/h,r.x=g,r.y=m}})(),jn=(function(){const i=new k,e=new P,t=new P;return function(s,n,r,o){ki(s,n,i);let a=i.x,l=i.y;if(a>=0&&a<=1&&l>=0&&l<=1){s.at(a,r),n.at(l,o);return}else if(a>=0&&a<=1){l<0?n.at(0,o):n.at(1,o),s.closestPointToPoint(o,!0,r);return}else if(l>=0&&l<=1){a<0?s.at(0,r):s.at(1,r),n.closestPointToPoint(r,!0,o);return}else{let c;a<0?c=s.start:c=s.end;let d;l<0?d=n.start:d=n.end;const u=e,h=t;if(s.closestPointToPoint(d,!0,e),n.closestPointToPoint(c,!0,t),u.distanceToSquared(d)<=h.distanceToSquared(c)){r.copy(u),o.copy(d);return}else{r.copy(c),o.copy(h);return}}}})(),Vi=(function(){const i=new P,e=new P,t=new Hs,s=new _e;return function(n,r){const{radius:o,center:a}=n,{a:l,b:c,c:d}=r;if(s.start=l,s.end=c,s.closestPointToPoint(a,!0,i).distanceTo(a)<=o||(s.start=l,s.end=d,s.closestPointToPoint(a,!0,i).distanceTo(a)<=o)||(s.start=c,s.end=d,s.closestPointToPoint(a,!0,i).distanceTo(a)<=o))return!0;const u=r.getPlane(t);if(Math.abs(u.distanceToPoint(a))<=o){const h=u.projectPoint(a,e);if(r.containsPoint(h))return!0}return!1}})(),Gi=1e-15;function an(i){return Math.abs(i)<Gi}class ve extends gt{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new P),this.satBounds=new Array(4).fill().map(()=>new Pe),this.points=[this.a,this.b,this.c],this.sphere=new ot,this.plane=new Hs,this.needsUpdate=!0}intersectsSphere(e){return Vi(e,this)}update(){const e=this.a,t=this.b,s=this.c,n=this.points,r=this.satAxes,o=this.satBounds,a=r[0],l=o[0];this.getNormal(a),l.setFromPoints(a,n);const c=r[1],d=o[1];c.subVectors(e,t),d.setFromPoints(c,n);const u=r[2],h=o[2];u.subVectors(t,s),h.setFromPoints(u,n);const f=r[3],w=o[3];f.subVectors(s,e),w.setFromPoints(f,n),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,e),this.needsUpdate=!1}}ve.prototype.closestPointToSegment=(function(){const i=new P,e=new P,t=new _e;return function(s,n=null,r=null){const{start:o,end:a}=s,l=this.points;let c,d=1/0;for(let u=0;u<3;u++){const h=(u+1)%3;t.start.copy(l[u]),t.end.copy(l[h]),jn(t,s,i,e),c=i.distanceToSquared(e),c<d&&(d=c,n&&n.copy(i),r&&r.copy(e))}return this.closestPointToPoint(o,i),c=o.distanceToSquared(i),c<d&&(d=c,n&&n.copy(i),r&&r.copy(o)),this.closestPointToPoint(a,i),c=a.distanceToSquared(i),c<d&&(d=c,n&&n.copy(i),r&&r.copy(a)),Math.sqrt(d)}})();ve.prototype.intersectsTriangle=(function(){const i=new ve,e=new Array(3),t=new Array(3),s=new Pe,n=new Pe,r=new P,o=new P,a=new P,l=new P,c=new P,d=new _e,u=new _e,h=new _e,f=new P;function w(g,m,p){const x=g.points;let v=0,y=-1;for(let b=0;b<3;b++){const{start:S,end:A}=d;S.copy(x[b]),A.copy(x[(b+1)%3]),d.delta(o);const _=an(m.distanceToPoint(S));if(an(m.normal.dot(o))&&_){p.copy(d),v=2;break}const E=m.intersectLine(d,f);if(!E&&_&&f.copy(S),(E||_)&&!an(f.distanceTo(A))){if(v<=1)(v===1?p.start:p.end).copy(f),_&&(y=v);else if(v>=2){(y===1?p.start:p.end).copy(f),v=2;break}if(v++,v===2&&y===-1)break}}return v}return function(g,m=null,p=!1){this.needsUpdate&&this.update(),g.isExtendedTriangle?g.needsUpdate&&g.update():(i.copy(g),i.update(),g=i);const x=this.plane,v=g.plane;if(Math.abs(x.normal.dot(v.normal))>1-1e-10){const y=this.satBounds,b=this.satAxes;t[0]=g.a,t[1]=g.b,t[2]=g.c;for(let _=0;_<4;_++){const E=y[_],M=b[_];if(s.setFromPoints(M,t),E.isSeparated(s))return!1}const S=g.satBounds,A=g.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let _=0;_<4;_++){const E=S[_],M=A[_];if(s.setFromPoints(M,e),E.isSeparated(s))return!1}for(let _=0;_<4;_++){const E=b[_];for(let M=0;M<4;M++){const R=A[M];if(r.crossVectors(E,R),s.setFromPoints(r,e),n.setFromPoints(r,t),s.isSeparated(n))return!1}}return m&&(p||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),m.start.set(0,0,0),m.end.set(0,0,0)),!0}else{const y=w(this,v,u);if(y===1&&g.containsPoint(u.end))return m&&(m.start.copy(u.end),m.end.copy(u.end)),!0;if(y!==2)return!1;const b=w(g,x,h);if(b===1&&this.containsPoint(h.end))return m&&(m.start.copy(h.end),m.end.copy(h.end)),!0;if(b!==2)return!1;if(u.delta(a),h.delta(l),a.dot(l)<0){let C=h.start;h.start=h.end,h.end=C}const S=u.start.dot(a),A=u.end.dot(a),_=h.start.dot(a),E=h.end.dot(a),M=A<_,R=S<E;return S!==E&&_!==A&&M===R?!1:(m&&(c.subVectors(u.start,h.start),c.dot(a)>0?m.start.copy(u.start):m.start.copy(h.start),c.subVectors(u.end,h.end),c.dot(a)<0?m.end.copy(u.end):m.end.copy(h.end)),!0)}}})();ve.prototype.distanceToPoint=(function(){const i=new P;return function(e){return this.closestPointToPoint(e,i),e.distanceTo(i)}})();ve.prototype.distanceToTriangle=(function(){const i=new P,e=new P,t=["a","b","c"],s=new _e,n=new _e;return function(r,o=null,a=null){const l=o||a?s:null;if(this.intersectsTriangle(r,l))return(o||a)&&(o&&l.getCenter(o),a&&l.getCenter(a)),0;let c=1/0;for(let d=0;d<3;d++){let u;const h=t[d],f=r[h];this.closestPointToPoint(f,i),u=f.distanceToSquared(i),u<c&&(c=u,o&&o.copy(i),a&&a.copy(f));const w=this[h];r.closestPointToPoint(w,i),u=w.distanceToSquared(i),u<c&&(c=u,o&&o.copy(w),a&&a.copy(i))}for(let d=0;d<3;d++){const u=t[d],h=t[(d+1)%3];s.set(this[u],this[h]);for(let f=0;f<3;f++){const w=t[f],g=t[(f+1)%3];n.set(r[w],r[g]),jn(s,n,i,e);const m=i.distanceToSquared(e);m<c&&(c=m,o&&o.copy(i),a&&a.copy(e))}}return Math.sqrt(c)}})();class se{constructor(e,t,s){this.isOrientedBox=!0,this.min=new P,this.max=new P,this.matrix=new Q,this.invMatrix=new Q,this.points=new Array(8).fill().map(()=>new P),this.satAxes=new Array(3).fill().map(()=>new P),this.satBounds=new Array(3).fill().map(()=>new Pe),this.alignedSatBounds=new Array(3).fill().map(()=>new Pe),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(e,t,s){this.min.copy(e),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}se.prototype.update=(function(){return function(){const i=this.matrix,e=this.min,t=this.max,s=this.points;for(let l=0;l<=1;l++)for(let c=0;c<=1;c++)for(let d=0;d<=1;d++){const u=1*l|2*c|4*d,h=s[u];h.x=l?t.x:e.x,h.y=c?t.y:e.y,h.z=d?t.z:e.z,h.applyMatrix4(i)}const n=this.satBounds,r=this.satAxes,o=s[0];for(let l=0;l<3;l++){const c=r[l],d=n[l],u=1<<l,h=s[u];c.subVectors(o,h),d.setFromPoints(c,s)}const a=this.alignedSatBounds;a[0].setFromPointsField(s,"x"),a[1].setFromPointsField(s,"y"),a[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}})();se.prototype.intersectsBox=(function(){const i=new Pe;return function(e){this.needsUpdate&&this.update();const t=e.min,s=e.max,n=this.satBounds,r=this.satAxes,o=this.alignedSatBounds;if(i.min=t.x,i.max=s.x,o[0].isSeparated(i)||(i.min=t.y,i.max=s.y,o[1].isSeparated(i))||(i.min=t.z,i.max=s.z,o[2].isSeparated(i)))return!1;for(let a=0;a<3;a++){const l=r[a],c=n[a];if(i.setFromBox(l,e),c.isSeparated(i))return!1}return!0}})();se.prototype.intersectsTriangle=(function(){const i=new ve,e=new Array(3),t=new Pe,s=new Pe,n=new P;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(i.copy(r),i.update(),r=i);const o=this.satBounds,a=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let u=0;u<3;u++){const h=o[u],f=a[u];if(t.setFromPoints(f,e),h.isSeparated(t))return!1}const l=r.satBounds,c=r.satAxes,d=this.points;for(let u=0;u<3;u++){const h=l[u],f=c[u];if(t.setFromPoints(f,d),h.isSeparated(t))return!1}for(let u=0;u<3;u++){const h=a[u];for(let f=0;f<4;f++){const w=c[f];if(n.crossVectors(h,w),t.setFromPoints(n,e),s.setFromPoints(n,d),t.isSeparated(s))return!1}}return!0}})();se.prototype.closestPointToPoint=(function(){return function(i,e){return this.needsUpdate&&this.update(),e.copy(i).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}})();se.prototype.distanceToPoint=(function(){const i=new P;return function(e){return this.closestPointToPoint(e,i),e.distanceTo(i)}})();se.prototype.distanceToBox=(function(){const i=["x","y","z"],e=new Array(12).fill().map(()=>new _e),t=new Array(12).fill().map(()=>new _e),s=new P,n=new P;return function(r,o=0,a=null,l=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(a||l)&&(r.getCenter(n),this.closestPointToPoint(n,s),r.closestPointToPoint(s,n),a&&a.copy(s),l&&l.copy(n)),0;const c=o*o,d=r.min,u=r.max,h=this.points;let f=1/0;for(let g=0;g<8;g++){const m=h[g];n.copy(m).clamp(d,u);const p=m.distanceToSquared(n);if(p<f&&(f=p,a&&a.copy(m),l&&l.copy(n),p<c))return Math.sqrt(p)}let w=0;for(let g=0;g<3;g++)for(let m=0;m<=1;m++)for(let p=0;p<=1;p++){const x=(g+1)%3,v=(g+2)%3,y=m<<x|p<<v,b=1<<g|m<<x|p<<v,S=h[y],A=h[b];e[w].set(S,A);const _=i[g],E=i[x],M=i[v],R=t[w],C=R.start,L=R.end;C[_]=d[_],C[E]=m?d[E]:u[E],C[M]=p?d[M]:u[E],L[_]=u[_],L[E]=m?d[E]:u[E],L[M]=p?d[M]:u[E],w++}for(let g=0;g<=1;g++)for(let m=0;m<=1;m++)for(let p=0;p<=1;p++){n.x=g?u.x:d.x,n.y=m?u.y:d.y,n.z=p?u.z:d.z,this.closestPointToPoint(n,s);const x=n.distanceToSquared(s);if(x<f&&(f=x,a&&a.copy(s),l&&l.copy(n),x<c))return Math.sqrt(x)}for(let g=0;g<12;g++){const m=e[g];for(let p=0;p<12;p++){const x=t[p];jn(m,x,s,n);const v=s.distanceToSquared(n);if(v<f&&(f=v,a&&a.copy(s),l&&l.copy(n),v<c))return Math.sqrt(v)}}return Math.sqrt(f)}})();class Dn{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}class qi extends Dn{constructor(){super(()=>new ve)}}const me=new qi;class Xi{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const e=[];let t=null;this.setBuffer=s=>{t&&e.push(t),t=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,e.length!==0&&this.setBuffer(e.pop())}}}const H=new Xi;let Oe,nt;const Xe=[],Lt=new Dn(()=>new $);function Ki(i,e,t,s,n,r){Oe=Lt.getPrimitive(),nt=Lt.getPrimitive(),Xe.push(Oe,nt),H.setBuffer(i._roots[e]);const o=Mn(0,i.geometry,t,s,n,r);H.clearBuffer(),Lt.releasePrimitive(Oe),Lt.releasePrimitive(nt),Xe.pop(),Xe.pop();const a=Xe.length;return a>0&&(nt=Xe[a-1],Oe=Xe[a-2]),o}function Mn(i,e,t,s,n=null,r=0,o=0){const{float32Array:a,uint16Array:l,uint32Array:c}=H;let d=i*2;if(oe(d,l)){const u=ie(i,c),h=he(d,l);return G(i,a,Oe),s(u,h,!1,o,r+i,Oe)}else{let u=function(R){const{uint16Array:C,uint32Array:L}=H;let B=R*2;for(;!oe(B,C);)R=fe(R),B=R*2;return ie(R,L)},h=function(R){const{uint16Array:C,uint32Array:L}=H;let B=R*2;for(;!oe(B,C);)R=pe(R,L),B=R*2;return ie(R,L)+he(B,C)};const f=fe(i),w=pe(i,c);let g=f,m=w,p,x,v,y;if(n&&(v=Oe,y=nt,G(g,a,v),G(m,a,y),p=n(v),x=n(y),x<p)){g=w,m=f;const R=p;p=x,x=R,v=y}v||(v=Oe,G(g,a,v));const b=oe(g*2,l),S=t(v,b,p,o+1,r+g);let A;if(S===ds){const R=u(g),C=h(g)-R;A=s(R,C,!0,o+1,r+g,v)}else A=S&&Mn(g,e,t,s,n,r,o+1);if(A)return!0;y=nt,G(m,a,y);const _=oe(m*2,l),E=t(y,_,x,o+1,r+m);let M;if(E===ds){const R=u(m),C=h(m)-R;M=s(R,C,!0,o+1,r+m,y)}else M=E&&Mn(m,e,t,s,n,r,o+1);return!!M}}const dt=new P,ln=new P;function Wi(i,e,t={},s=0,n=1/0){const r=s*s,o=n*n;let a=1/0,l=null;if(i.shapecast({boundsTraverseOrder:d=>(dt.copy(e).clamp(d.min,d.max),dt.distanceToSquared(e)),intersectsBounds:(d,u,h)=>h<a&&h<o,intersectsTriangle:(d,u)=>{d.closestPointToPoint(e,dt);const h=e.distanceToSquared(dt);return h<a&&(ln.copy(dt),a=h,l=u),h<r}}),a===1/0)return null;const c=Math.sqrt(a);return t.point?t.point.copy(ln):t.point=ln.clone(),t.distance=c,t.faceIndex=l,t}const Ke=new P,We=new P,$e=new P,It=new k,Bt=new k,Ot=new k,gs=new P,xs=new P,vs=new P,Nt=new P;function $i(i,e,t,s,n,r){let o;return r===Ls?o=i.intersectTriangle(s,t,e,!0,n):o=i.intersectTriangle(e,t,s,r!==Us,n),o===null?null:{distance:i.origin.distanceTo(n),point:n.clone()}}function Yi(i,e,t,s,n,r,o,a,l){Ke.fromBufferAttribute(e,r),We.fromBufferAttribute(e,o),$e.fromBufferAttribute(e,a);const c=$i(i,Ke,We,$e,Nt,l);if(c){s&&(It.fromBufferAttribute(s,r),Bt.fromBufferAttribute(s,o),Ot.fromBufferAttribute(s,a),c.uv=gt.getInterpolation(Nt,Ke,We,$e,It,Bt,Ot,new k)),n&&(It.fromBufferAttribute(n,r),Bt.fromBufferAttribute(n,o),Ot.fromBufferAttribute(n,a),c.uv1=gt.getInterpolation(Nt,Ke,We,$e,It,Bt,Ot,new k)),t&&(gs.fromBufferAttribute(t,r),xs.fromBufferAttribute(t,o),vs.fromBufferAttribute(t,a),c.normal=gt.getInterpolation(Nt,Ke,We,$e,gs,xs,vs,new P),c.normal.dot(i.direction)>0&&c.normal.multiplyScalar(-1));const d={a:r,b:o,c:a,normal:new P,materialIndex:0};gt.getNormal(Ke,We,$e,d.normal),c.face=d,c.faceIndex=r}return c}function Wt(i,e,t,s,n){const r=s*3;let o=r+0,a=r+1,l=r+2;const c=i.index;i.index&&(o=c.getX(o),a=c.getX(a),l=c.getX(l));const{position:d,normal:u,uv:h,uv1:f}=i.attributes,w=Yi(t,d,u,h,f,o,a,l,e);return w?(w.faceIndex=s,n&&n.push(w),w):null}function W(i,e,t,s){const n=i.a,r=i.b,o=i.c;let a=e,l=e+1,c=e+2;t&&(a=t.getX(a),l=t.getX(l),c=t.getX(c)),n.x=s.getX(a),n.y=s.getY(a),n.z=s.getZ(a),r.x=s.getX(l),r.y=s.getY(l),r.z=s.getZ(l),o.x=s.getX(c),o.y=s.getY(c),o.z=s.getZ(c)}function Zi(i,e,t,s,n,r){const{geometry:o,_indirectBuffer:a}=i;for(let l=s,c=s+n;l<c;l++)Wt(o,e,t,l,r)}function Qi(i,e,t,s,n){const{geometry:r,_indirectBuffer:o}=i;let a=1/0,l=null;for(let c=s,d=s+n;c<d;c++){let u;u=Wt(r,e,t,c),u&&u.distance<a&&(l=u,a=u.distance)}return l}function Ji(i,e,t,s,n,r,o){const{geometry:a}=t,{index:l}=a,c=a.attributes.position;for(let d=i,u=e+i;d<u;d++){let h;if(h=d,W(o,h*3,l,c),o.needsUpdate=!0,s(o,h,n,r))return!0}return!1}function ea(i,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=i.geometry,s=t.index?t.index.array:null,n=t.attributes.position;let r,o,a,l,c=0;const d=i._roots;for(let h=0,f=d.length;h<f;h++)r=d[h],o=new Uint32Array(r),a=new Uint16Array(r),l=new Float32Array(r),u(0,c),c+=r.byteLength;function u(h,f,w=!1){const g=h*2;if(a[g+15]===Kt){const m=o[h+6],p=a[g+14];let x=1/0,v=1/0,y=1/0,b=-1/0,S=-1/0,A=-1/0;for(let _=3*m,E=3*(m+p);_<E;_++){let M=s[_];const R=n.getX(M),C=n.getY(M),L=n.getZ(M);R<x&&(x=R),R>b&&(b=R),C<v&&(v=C),C>S&&(S=C),L<y&&(y=L),L>A&&(A=L)}return l[h+0]!==x||l[h+1]!==v||l[h+2]!==y||l[h+3]!==b||l[h+4]!==S||l[h+5]!==A?(l[h+0]=x,l[h+1]=v,l[h+2]=y,l[h+3]=b,l[h+4]=S,l[h+5]=A,!0):!1}else{const m=h+8,p=o[h+6],x=m+f,v=p+f;let y=w,b=!1,S=!1;e?y||(b=e.has(x),S=e.has(v),y=!b&&!S):(b=!0,S=!0);const A=y||b,_=y||S;let E=!1;A&&(E=u(m,f,y));let M=!1;_&&(M=u(p,f,y));const R=E||M;if(R)for(let C=0;C<3;C++){const L=m+C,B=p+C,F=l[L],D=l[L+3],Z=l[B],J=l[B+3];l[h+C]=F<Z?F:Z,l[h+C+3]=D>J?D:J}return R}}}const ys=new $;function Ue(i,e,t,s){return G(i,e,ys),t.intersectBox(ys,s)}function ta(i,e,t,s,n,r){const{geometry:o,_indirectBuffer:a}=i;for(let l=s,c=s+n;l<c;l++){let d=a?a[l]:l;Wt(o,e,t,d,r)}}function na(i,e,t,s,n){const{geometry:r,_indirectBuffer:o}=i;let a=1/0,l=null;for(let c=s,d=s+n;c<d;c++){let u;u=Wt(r,e,t,o?o[c]:c),u&&u.distance<a&&(l=u,a=u.distance)}return l}function sa(i,e,t,s,n,r,o){const{geometry:a}=t,{index:l}=a,c=a.attributes.position;for(let d=i,u=e+i;d<u;d++){let h;if(h=t.resolveTriangleIndex(d),W(o,h*3,l,c),o.needsUpdate=!0,s(o,h,n,r))return!0}return!1}const ws=new P;function ra(i,e,t,s,n){H.setBuffer(i._roots[e]),Pn(0,i,t,s,n),H.clearBuffer()}function Pn(i,e,t,s,n){const{float32Array:r,uint16Array:o,uint32Array:a}=H,l=i*2;if(oe(l,o)){const c=ie(i,a),d=he(l,o);Zi(e,t,s,c,d,n)}else{const c=fe(i);Ue(c,r,s,ws)&&Pn(c,e,t,s,n);const d=pe(i,a);Ue(d,r,s,ws)&&Pn(d,e,t,s,n)}}const As=new P,oa=["x","y","z"];function ia(i,e,t,s){H.setBuffer(i._roots[e]);const n=Cn(0,i,t,s);return H.clearBuffer(),n}function Cn(i,e,t,s){const{float32Array:n,uint16Array:r,uint32Array:o}=H;let a=i*2;if(oe(a,r)){const l=ie(i,o),c=he(a,r);return Qi(e,t,s,l,c)}else{const l=or(i,o),c=oa[l],d=s.direction[c]>=0;let u,h;d?(u=fe(i),h=pe(i,o)):(u=pe(i,o),h=fe(i));const f=Ue(u,n,s,As)?Cn(u,e,t,s):null;if(f){const g=f.point[c];if(d?g<=n[h+l]:g>=n[h+l+3])return f}const w=Ue(h,n,s,As)?Cn(h,e,t,s):null;return f&&w?f.distance<=w.distance?f:w:f||w||null}}const zt=new $,Ye=new ve,Ze=new ve,ht=new Q,bs=new se,Ut=new se;function aa(i,e,t,s){H.setBuffer(i._roots[e]);const n=Rn(0,i,t,s);return H.clearBuffer(),n}function Rn(i,e,t,s,n=null){const{float32Array:r,uint16Array:o,uint32Array:a}=H;let l=i*2;if(n===null&&(t.boundingBox||t.computeBoundingBox(),bs.set(t.boundingBox.min,t.boundingBox.max,s),n=bs),oe(l,o)){const c=e.geometry,d=c.index,u=c.attributes.position,h=t.index,f=t.attributes.position,w=ie(i,a),g=he(l,o);if(ht.copy(s).invert(),t.boundsTree)return G(i,r,Ut),Ut.matrix.copy(ht),Ut.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:m=>Ut.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(s),m.b.applyMatrix4(s),m.c.applyMatrix4(s),m.needsUpdate=!0;for(let p=w*3,x=(g+w)*3;p<x;p+=3)if(W(Ze,p,d,u),Ze.needsUpdate=!0,m.intersectsTriangle(Ze))return!0;return!1}});for(let m=w*3,p=(g+w)*3;m<p;m+=3){W(Ye,m,d,u),Ye.a.applyMatrix4(ht),Ye.b.applyMatrix4(ht),Ye.c.applyMatrix4(ht),Ye.needsUpdate=!0;for(let x=0,v=h.count;x<v;x+=3)if(W(Ze,x,h,f),Ze.needsUpdate=!0,Ye.intersectsTriangle(Ze))return!0}}else{const c=i+8,d=a[i+6];return G(c,r,zt),!!(n.intersectsBox(zt)&&Rn(c,e,t,s,n)||(G(d,r,zt),n.intersectsBox(zt)&&Rn(d,e,t,s,n)))}}const Ft=new Q,cn=new se,ft=new se,la=new P,ca=new P,ua=new P,da=new P;function ha(i,e,t,s={},n={},r=0,o=1/0){e.boundingBox||e.computeBoundingBox(),cn.set(e.boundingBox.min,e.boundingBox.max,t),cn.needsUpdate=!0;const a=i.geometry,l=a.attributes.position,c=a.index,d=e.attributes.position,u=e.index,h=me.getPrimitive(),f=me.getPrimitive();let w=la,g=ca,m=null,p=null;n&&(m=ua,p=da);let x=1/0,v=null,y=null;return Ft.copy(t).invert(),ft.matrix.copy(Ft),i.shapecast({boundsTraverseOrder:b=>cn.distanceToBox(b),intersectsBounds:(b,S,A)=>A<x&&A<o?(S&&(ft.min.copy(b.min),ft.max.copy(b.max),ft.needsUpdate=!0),!0):!1,intersectsRange:(b,S)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:A=>ft.distanceToBox(A),intersectsBounds:(A,_,E)=>E<x&&E<o,intersectsRange:(A,_)=>{for(let E=A,M=A+_;E<M;E++){W(f,3*E,u,d),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let R=b,C=b+S;R<C;R++){W(h,3*R,c,l),h.needsUpdate=!0;const L=h.distanceToTriangle(f,w,m);if(L<x&&(g.copy(w),p&&p.copy(m),x=L,v=R,y=E),L<r)return!0}}}});{const A=at(e);for(let _=0,E=A;_<E;_++){W(f,3*_,u,d),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let M=b,R=b+S;M<R;M++){W(h,3*M,c,l),h.needsUpdate=!0;const C=h.distanceToTriangle(f,w,m);if(C<x&&(g.copy(w),p&&p.copy(m),x=C,v=M,y=_),C<r)return!0}}}}}),me.releasePrimitive(h),me.releasePrimitive(f),x===1/0?null:(s.point?s.point.copy(g):s.point=g.clone(),s.distance=x,s.faceIndex=v,n&&(n.point?n.point.copy(p):n.point=p.clone(),n.point.applyMatrix4(Ft),g.applyMatrix4(Ft),n.distance=g.sub(n.point).length(),n.faceIndex=y),s)}function fa(i,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=i.geometry,s=t.index?t.index.array:null,n=t.attributes.position;let r,o,a,l,c=0;const d=i._roots;for(let h=0,f=d.length;h<f;h++)r=d[h],o=new Uint32Array(r),a=new Uint16Array(r),l=new Float32Array(r),u(0,c),c+=r.byteLength;function u(h,f,w=!1){const g=h*2;if(a[g+15]===Kt){const m=o[h+6],p=a[g+14];let x=1/0,v=1/0,y=1/0,b=-1/0,S=-1/0,A=-1/0;for(let _=m,E=m+p;_<E;_++){const M=3*i.resolveTriangleIndex(_);for(let R=0;R<3;R++){let C=M+R;C=s?s[C]:C;const L=n.getX(C),B=n.getY(C),F=n.getZ(C);L<x&&(x=L),L>b&&(b=L),B<v&&(v=B),B>S&&(S=B),F<y&&(y=F),F>A&&(A=F)}}return l[h+0]!==x||l[h+1]!==v||l[h+2]!==y||l[h+3]!==b||l[h+4]!==S||l[h+5]!==A?(l[h+0]=x,l[h+1]=v,l[h+2]=y,l[h+3]=b,l[h+4]=S,l[h+5]=A,!0):!1}else{const m=h+8,p=o[h+6],x=m+f,v=p+f;let y=w,b=!1,S=!1;e?y||(b=e.has(x),S=e.has(v),y=!b&&!S):(b=!0,S=!0);const A=y||b,_=y||S;let E=!1;A&&(E=u(m,f,y));let M=!1;_&&(M=u(p,f,y));const R=E||M;if(R)for(let C=0;C<3;C++){const L=m+C,B=p+C,F=l[L],D=l[L+3],Z=l[B],J=l[B+3];l[h+C]=F<Z?F:Z,l[h+C+3]=D>J?D:J}return R}}}const Ss=new P;function pa(i,e,t,s,n){H.setBuffer(i._roots[e]),Ln(0,i,t,s,n),H.clearBuffer()}function Ln(i,e,t,s,n){const{float32Array:r,uint16Array:o,uint32Array:a}=H,l=i*2;if(oe(l,o)){const c=ie(i,a),d=he(l,o);ta(e,t,s,c,d,n)}else{const c=fe(i);Ue(c,r,s,Ss)&&Ln(c,e,t,s,n);const d=pe(i,a);Ue(d,r,s,Ss)&&Ln(d,e,t,s,n)}}const _s=new P,ma=["x","y","z"];function ga(i,e,t,s){H.setBuffer(i._roots[e]);const n=In(0,i,t,s);return H.clearBuffer(),n}function In(i,e,t,s){const{float32Array:n,uint16Array:r,uint32Array:o}=H;let a=i*2;if(oe(a,r)){const l=ie(i,o),c=he(a,r);return na(e,t,s,l,c)}else{const l=or(i,o),c=ma[l],d=s.direction[c]>=0;let u,h;d?(u=fe(i),h=pe(i,o)):(u=pe(i,o),h=fe(i));const f=Ue(u,n,s,_s)?In(u,e,t,s):null;if(f){const g=f.point[c];if(d?g<=n[h+l]:g>=n[h+l+3])return f}const w=Ue(h,n,s,_s)?In(h,e,t,s):null;return f&&w?f.distance<=w.distance?f:w:f||w||null}}const jt=new $,Qe=new ve,Je=new ve,pt=new Q,Ts=new se,Dt=new se;function xa(i,e,t,s){H.setBuffer(i._roots[e]);const n=Bn(0,i,t,s);return H.clearBuffer(),n}function Bn(i,e,t,s,n=null){const{float32Array:r,uint16Array:o,uint32Array:a}=H;let l=i*2;if(n===null&&(t.boundingBox||t.computeBoundingBox(),Ts.set(t.boundingBox.min,t.boundingBox.max,s),n=Ts),oe(l,o)){const c=e.geometry,d=c.index,u=c.attributes.position,h=t.index,f=t.attributes.position,w=ie(i,a),g=he(l,o);if(pt.copy(s).invert(),t.boundsTree)return G(i,r,Dt),Dt.matrix.copy(pt),Dt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:m=>Dt.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(s),m.b.applyMatrix4(s),m.c.applyMatrix4(s),m.needsUpdate=!0;for(let p=w,x=g+w;p<x;p++)if(W(Je,3*e.resolveTriangleIndex(p),d,u),Je.needsUpdate=!0,m.intersectsTriangle(Je))return!0;return!1}});for(let m=w,p=g+w;m<p;m++){const x=e.resolveTriangleIndex(m);W(Qe,3*x,d,u),Qe.a.applyMatrix4(pt),Qe.b.applyMatrix4(pt),Qe.c.applyMatrix4(pt),Qe.needsUpdate=!0;for(let v=0,y=h.count;v<y;v+=3)if(W(Je,v,h,f),Je.needsUpdate=!0,Qe.intersectsTriangle(Je))return!0}}else{const c=i+8,d=a[i+6];return G(c,r,jt),!!(n.intersectsBox(jt)&&Bn(c,e,t,s,n)||(G(d,r,jt),n.intersectsBox(jt)&&Bn(d,e,t,s,n)))}}const Ht=new Q,un=new se,mt=new se,va=new P,ya=new P,wa=new P,Aa=new P;function ba(i,e,t,s={},n={},r=0,o=1/0){e.boundingBox||e.computeBoundingBox(),un.set(e.boundingBox.min,e.boundingBox.max,t),un.needsUpdate=!0;const a=i.geometry,l=a.attributes.position,c=a.index,d=e.attributes.position,u=e.index,h=me.getPrimitive(),f=me.getPrimitive();let w=va,g=ya,m=null,p=null;n&&(m=wa,p=Aa);let x=1/0,v=null,y=null;return Ht.copy(t).invert(),mt.matrix.copy(Ht),i.shapecast({boundsTraverseOrder:b=>un.distanceToBox(b),intersectsBounds:(b,S,A)=>A<x&&A<o?(S&&(mt.min.copy(b.min),mt.max.copy(b.max),mt.needsUpdate=!0),!0):!1,intersectsRange:(b,S)=>{if(e.boundsTree){const A=e.boundsTree;return A.shapecast({boundsTraverseOrder:_=>mt.distanceToBox(_),intersectsBounds:(_,E,M)=>M<x&&M<o,intersectsRange:(_,E)=>{for(let M=_,R=_+E;M<R;M++){const C=A.resolveTriangleIndex(M);W(f,3*C,u,d),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let L=b,B=b+S;L<B;L++){const F=i.resolveTriangleIndex(L);W(h,3*F,c,l),h.needsUpdate=!0;const D=h.distanceToTriangle(f,w,m);if(D<x&&(g.copy(w),p&&p.copy(m),x=D,v=L,y=M),D<r)return!0}}}})}else{const A=at(e);for(let _=0,E=A;_<E;_++){W(f,3*_,u,d),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let M=b,R=b+S;M<R;M++){const C=i.resolveTriangleIndex(M);W(h,3*C,c,l),h.needsUpdate=!0;const L=h.distanceToTriangle(f,w,m);if(L<x&&(g.copy(w),p&&p.copy(m),x=L,v=M,y=_),L<r)return!0}}}}}),me.releasePrimitive(h),me.releasePrimitive(f),x===1/0?null:(s.point?s.point.copy(g):s.point=g.clone(),s.distance=x,s.faceIndex=v,n&&(n.point?n.point.copy(p):n.point=p.clone(),n.point.applyMatrix4(Ht),g.applyMatrix4(Ht),n.distance=g.sub(n.point).length(),n.faceIndex=y),s)}function Sa(){return typeof SharedArrayBuffer<"u"}const wt=new H.constructor,Xt=new H.constructor,Be=new Dn(()=>new $),et=new $,tt=new $,dn=new $,hn=new $;let fn=!1;function _a(i,e,t,s){if(fn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");fn=!0;const n=i._roots,r=e._roots;let o,a=0,l=0;const c=new Q().copy(t).invert();for(let d=0,u=n.length;d<u;d++){wt.setBuffer(n[d]),l=0;const h=Be.getPrimitive();G(0,wt.float32Array,h),h.applyMatrix4(c);for(let f=0,w=r.length;f<w&&(Xt.setBuffer(r[d]),o=xe(0,0,t,c,s,a,l,0,0,h),Xt.clearBuffer(),l+=r[f].length,!o);f++);if(Be.releasePrimitive(h),wt.clearBuffer(),a+=n[d].length,o)break}return fn=!1,o}function xe(i,e,t,s,n,r=0,o=0,a=0,l=0,c=null,d=!1){let u,h;d?(u=Xt,h=wt):(u=wt,h=Xt);const f=u.float32Array,w=u.uint32Array,g=u.uint16Array,m=h.float32Array,p=h.uint32Array,x=h.uint16Array,v=i*2,y=e*2,b=oe(v,g),S=oe(y,x);let A=!1;if(S&&b)d?A=n(ie(e,p),he(e*2,x),ie(i,w),he(i*2,g),l,o+e,a,r+i):A=n(ie(i,w),he(i*2,g),ie(e,p),he(e*2,x),a,r+i,l,o+e);else if(S){const _=Be.getPrimitive();G(e,m,_),_.applyMatrix4(t);const E=fe(i),M=pe(i,w);G(E,f,et),G(M,f,tt);const R=_.intersectsBox(et),C=_.intersectsBox(tt);A=R&&xe(e,E,s,t,n,o,r,l,a+1,_,!d)||C&&xe(e,M,s,t,n,o,r,l,a+1,_,!d),Be.releasePrimitive(_)}else{const _=fe(e),E=pe(e,p);G(_,m,dn),G(E,m,hn);const M=c.intersectsBox(dn),R=c.intersectsBox(hn);if(M&&R)A=xe(i,_,t,s,n,r,o,a,l+1,c,d)||xe(i,E,t,s,n,r,o,a,l+1,c,d);else if(M)if(b)A=xe(i,_,t,s,n,r,o,a,l+1,c,d);else{const C=Be.getPrimitive();C.copy(dn).applyMatrix4(t);const L=fe(i),B=pe(i,w);G(L,f,et),G(B,f,tt);const F=C.intersectsBox(et),D=C.intersectsBox(tt);A=F&&xe(_,L,s,t,n,o,r,l,a+1,C,!d)||D&&xe(_,B,s,t,n,o,r,l,a+1,C,!d),Be.releasePrimitive(C)}else if(R)if(b)A=xe(i,E,t,s,n,r,o,a,l+1,c,d);else{const C=Be.getPrimitive();C.copy(hn).applyMatrix4(t);const L=fe(i),B=pe(i,w);G(L,f,et),G(B,f,tt);const F=C.intersectsBox(et),D=C.intersectsBox(tt);A=F&&xe(E,L,s,t,n,o,r,l,a+1,C,!d)||D&&xe(E,B,s,t,n,o,r,l,a+1,C,!d),Be.releasePrimitive(C)}}return A}const kt=new se,Es=new $,Ta={strategy:tr,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class Hn{static serialize(e,t={}){t={cloneBuffers:!0,...t};const s=e.geometry,n=e._roots,r=e._indirectBuffer,o=s.getIndex();let a;return t.cloneBuffers?a={roots:n.map(l=>l.slice()),index:o.array.slice(),indirectBuffer:r?r.slice():null}:a={roots:n,index:o.array,indirectBuffer:r},a}static deserialize(e,t,s={}){s={setIndex:!0,indirect:!!e.indirectBuffer,...s};const{index:n,roots:r,indirectBuffer:o}=e,a=new Hn(t,{...s,[sn]:!0});if(a._roots=r,a._indirectBuffer=o||null,s.setIndex){const l=t.getIndex();if(l===null){const c=new vt(e.index,1,!1);t.setIndex(c)}else l.array!==n&&(l.array.set(n),l.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({...Ta,[sn]:!1},t),t.useSharedArrayBuffer&&!Sa())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=e,this._roots=null,this._indirectBuffer=null,t[sn]||(Hi(this,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new $)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=t.indirect?n=>s[n]:n=>n}refit(e=null){return(this.indirect?fa:ea)(this,e)}traverse(e,t=0){const s=this._roots[t],n=new Uint32Array(s),r=new Uint16Array(s);o(0);function o(a,l=0){const c=a*2,d=r[c+15]===Kt;if(d){const u=n[a+6],h=r[c+14];e(l,d,new Float32Array(s,a*4,6),u,h)}else{const u=a+yt/4,h=n[a+6],f=n[a+7];e(l,d,new Float32Array(s,a*4,6),f)||(o(u,l+1),o(h,l+1))}}}raycast(e,t=rt){const s=this._roots,n=this.geometry,r=[],o=t.isMaterial,a=Array.isArray(t),l=n.groups,c=o?t.side:t,d=this.indirect?pa:ra;for(let u=0,h=s.length;u<h;u++){const f=a?t[l[u].materialIndex].side:c,w=r.length;if(d(this,u,f,e,r),a){const g=l[u].materialIndex;for(let m=w,p=r.length;m<p;m++)r[m].face.materialIndex=g}}return r}raycastFirst(e,t=rt){const s=this._roots,n=this.geometry,r=t.isMaterial,o=Array.isArray(t);let a=null;const l=n.groups,c=r?t.side:t,d=this.indirect?ga:ia;for(let u=0,h=s.length;u<h;u++){const f=o?t[l[u].materialIndex].side:c,w=d(this,u,f,e);w!=null&&(a==null||w.distance<a.distance)&&(a=w,o&&(w.face.materialIndex=l[u].materialIndex))}return a}intersectsGeometry(e,t){let s=!1;const n=this._roots,r=this.indirect?xa:aa;for(let o=0,a=n.length;o<a&&(s=r(this,o,e,t),!s);o++);return s}shapecast(e){const t=me.getPrimitive(),s=this.indirect?sa:Ji;let{boundsTraverseOrder:n,intersectsBounds:r,intersectsRange:o,intersectsTriangle:a}=e;if(o&&a){const u=o;o=(h,f,w,g,m)=>u(h,f,w,g,m)?!0:s(h,f,this,a,w,g,t)}else o||(a?o=(u,h,f,w)=>s(u,h,this,a,f,w,t):o=(u,h,f)=>f);let l=!1,c=0;const d=this._roots;for(let u=0,h=d.length;u<h;u++){const f=d[u];if(l=Ki(this,u,r,o,n,c),l)break;c+=f.byteLength}return me.releasePrimitive(t),l}bvhcast(e,t,s){let{intersectsRanges:n,intersectsTriangles:r}=s;const o=me.getPrimitive(),a=this.geometry.index,l=this.geometry.attributes.position,c=this.indirect?w=>{const g=this.resolveTriangleIndex(w);W(o,g*3,a,l)}:w=>{W(o,w*3,a,l)},d=me.getPrimitive(),u=e.geometry.index,h=e.geometry.attributes.position,f=e.indirect?w=>{const g=e.resolveTriangleIndex(w);W(d,g*3,u,h)}:w=>{W(d,w*3,u,h)};if(r){const w=(g,m,p,x,v,y,b,S)=>{for(let A=p,_=p+x;A<_;A++){f(A),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let E=g,M=g+m;E<M;E++)if(c(E),o.needsUpdate=!0,r(o,d,E,A,v,y,b,S))return!0}return!1};if(n){const g=n;n=function(m,p,x,v,y,b,S,A){return g(m,p,x,v,y,b,S,A)?!0:w(m,p,x,v,y,b,S,A)}}else n=w}return _a(this,e,t,n)}intersectsBox(e,t){return kt.set(e.min,e.max,t),kt.needsUpdate=!0,this.shapecast({intersectsBounds:s=>kt.intersectsBox(s),intersectsTriangle:s=>kt.intersectsTriangle(s)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,s={},n={},r=0,o=1/0){return(this.indirect?ba:ha)(this,e,t,s,n,r,o)}closestPointToPoint(e,t={},s=0,n=1/0){return Wi(this,e,t,s,n)}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(t=>{G(0,new Float32Array(t),Es),e.union(Es)}),e}}function Ms(i,e,t){return i===null||(i.point.applyMatrix4(e.matrixWorld),i.distance=i.point.distanceTo(t.ray.origin),i.object=e,i.distance<t.near||i.distance>t.far)?null:i}const pn=new fr,Ps=new Q,Ea=Ne.prototype.raycast;function Ma(i,e){if(this.geometry.boundsTree){if(this.material===void 0)return;Ps.copy(this.matrixWorld).invert(),pn.copy(i.ray).applyMatrix4(Ps);const t=this.geometry.boundsTree;if(i.firstHitOnly===!0){const s=Ms(t.raycastFirst(pn,this.material),this,i);s&&e.push(s)}else{const s=t.raycast(pn,this.material);for(let n=0,r=s.length;n<r;n++){const o=Ms(s[n],this,i);o&&e.push(o)}}}else Ea.call(this,i,e)}function Pa(i){return this.boundsTree=new Hn(this,i),this.boundsTree}function Ca(){this.boundsTree=null}const Cs=i=>i.isMesh,Ra=T.forwardRef(({enabled:i=!0,firstHitOnly:e=!1,children:t,strategy:s=nr,verbose:n=!1,setBoundingBox:r=!0,maxDepth:o=40,maxLeafTris:a=10,indirect:l=!1,...c},d)=>{const u=T.useRef(null),h=Me(f=>f.raycaster);return T.useImperativeHandle(d,()=>u.current,[]),T.useEffect(()=>{if(i){const f={strategy:s,verbose:n,setBoundingBox:r,maxDepth:o,maxLeafTris:a,indirect:l},w=u.current;return h.firstHitOnly=e,w.traverse(g=>{Cs(g)&&!g.geometry.boundsTree&&g.raycast===Ne.prototype.raycast&&(g.raycast=Ma,g.geometry.computeBoundsTree=Pa,g.geometry.disposeBoundsTree=Ca,g.geometry.computeBoundsTree(f))}),()=>{delete h.firstHitOnly,w.traverse(g=>{Cs(g)&&g.geometry.boundsTree&&(g.geometry.disposeBoundsTree(),g.raycast=Ne.prototype.raycast)})}}},[]),T.createElement("group",At({ref:u},c),t)}),La=T.forwardRef(function({children:i,disable:e,disableX:t,disableY:s,disableZ:n,left:r,right:o,top:a,bottom:l,front:c,back:d,onCentered:u,precise:h=!0,cacheKey:f=0,...w},g){const m=T.useRef(null),p=T.useRef(null),x=T.useRef(null);return T.useLayoutEffect(()=>{p.current.matrixWorld.identity();const v=new $().setFromObject(x.current,h),y=new P,b=new ot,S=v.max.x-v.min.x,A=v.max.y-v.min.y,_=v.max.z-v.min.z;v.getCenter(y),v.getBoundingSphere(b);const E=a?A/2:l?-A/2:0,M=r?-S/2:o?S/2:0,R=c?_/2:d?-_/2:0;p.current.position.set(e||t?0:-y.x+M,e||s?0:-y.y+E,e||n?0:-y.z+R),typeof u<"u"&&u({parent:m.current.parent,container:m.current,width:S,height:A,depth:_,boundingBox:v,boundingSphere:b,center:y,verticalAlignment:E,horizontalAlignment:M,depthAlignment:R})},[f,u,a,r,c,e,t,s,n,h,o,l,d]),T.useImperativeHandle(g,()=>m.current,[]),T.createElement("group",At({ref:m},w),T.createElement("group",{ref:p},T.createElement("group",{ref:x},i)))});function Ia(){const{controllers:i}=X(),e=T.useRef(),t=T.useRef();return it(()=>{if(i&&i[0]&&i[1]){if(i[0].controller){const s=i[0].hand.joints["index-finger-tip"].position;e.current.position.copy(s)}if(i[1].controller){const s=i[1].hand.joints["index-finger-tip"].position;t.current.position.copy(s)}}}),I.jsxs(I.Fragment,{children:[I.jsxs("mesh",{name:"leftTipBbox",ref:t,children:[I.jsx("boxGeometry",{args:[.02,.02,.02]}),I.jsx("meshStandardMaterial",{color:"blue",transparent:!0,opacity:0})]}),I.jsxs("mesh",{name:"rightTipBbox",ref:e,children:[I.jsx("boxGeometry",{args:[.02,.02,.02]}),I.jsx("meshStandardMaterial",{color:"orange",transparent:!0,opacity:0})]})]})}function mn(i){const{currentLine:e,scale:t}=i,s=T.useRef();return I.jsxs("group",{children:[I.jsx(La,{bottom:!0,right:!0,position:[e.midPoint.x,e.midPoint.y,e.midPoint.z],rotation:[0,0,0],children:I.jsx(er,{color:"gray",scale:.05,ref:s,children:`${(e.startPoint.distanceTo(e.endPoint)*t).toFixed(2)} µm`})}),I.jsx(_i,{points:[e.startPoint,e.endPoint],color:"white",lineWidth:2,dashed:!1,segments:!0})]})}function Ba(i){const{segmentationGroup:e,segmentationSettings:t,segmentationSceneScale:s,renderingSettings:n,materialRef:r,highlightEntity:o,setObsHighlight:a}=i,l=T.useRef(),c=T.useRef(),d=T.useRef(),{isPresenting:u}=X();T.useEffect(()=>{u&&l?.current?r!==null&&(r.current.material.uniforms.u_physical_Pixel.value=.2):u||r!==null&&(r.current.material.uniforms.u_physical_Pixel.value=2.5)},[u]);const{scene:h}=Me(),{controllers:f}=X(),[w,g]=T.useState(!1),[m,p]=T.useState(!1),[x,v]=T.useState(!1),[y,b]=T.useState({startPoint:new P,midPoint:new P,endPoint:new P,setStartPoint:!1,setEndPoint:!1}),[S,A]=T.useState([]),[_,E]=T.useState(0);return it(()=>{if(u){const M=h.getObjectByName("rightTipBbox"),R=h.getObjectByName("leftTipBbox"),C=new $().setFromObject(R),L=new $().setFromObject(M);let B=!1;if(E(_-1),C.intersectsBox(L)&&C.max.x!==-L.min.x&&(g(!0),v(!0),b({startPoint:new P,midPoint:new P,endPoint:new P,setStartPoint:!1,setEndPoint:!1})),w){let F=f[1].hand.joints["index-finger-tip"].position.clone(),D=f[0].hand.joints["index-finger-tip"].position.clone();F=F.applyMatrix4(d.current.matrixWorld.clone().invert()),D=D.applyMatrix4(d.current.matrixWorld.clone().invert());let Z=F.clone(),J=D.clone();y.setStartPoint&&(Z=y.startPoint),y.setEndPoint&&(J=y.endPoint),b({startPoint:Z,midPoint:new P().addVectors(Z,J).multiplyScalar(.5),endPoint:J,setStartPoint:y.setStartPoint,setEndPoint:y.setEndPoint}),f[0].hand.inputState.pinching===!0&&b({startPoint:y.startPoint,midPoint:y.midPoint,endPoint:y.endPoint,setStartPoint:y.setStartPoint,setEndPoint:!0}),f[1].hand.inputState.pinching===!0&&b({startPoint:y.startPoint,midPoint:y.midPoint,endPoint:y.endPoint,setStartPoint:!0,setEndPoint:y.setEndPoint}),y.setStartPoint&&y.setEndPoint&&(S.push(y),A(S),v(!1),g(!1),E(8))}else _<=0&&l?.current&&u&&(l.current.children[0].children.forEach((F,D)=>{const Z=l.current.children[0].children[D],J=new $().setFromObject(Z),St=C.intersectsBox(J),$t=L.intersectsBox(J);(St||$t)&&(B=!0,a(Z.name),p(!0),f[1]!==void 0&&St&&f[1].hand.inputState.pinching===!0&&(E(10),B=!1,f[1].hand.inputState.pinching=!1),f[0]!==void 0&&$t&&f[0].hand.inputState.pinching===!0&&(E(10),B=!1,f[0].hand.inputState.pinching=!1))}),!B&&m&&(a(null),p(!1)))}},[w,m,y,S,x,_,u]),I.jsx("group",{children:X().isPresenting?I.jsxs(lo,{children:[I.jsxs("group",{ref:d,children:[e?.visible?I.jsxs("group",{children:[I.jsx("hemisphereLight",{skyColor:8421504,groundColor:6316128}),I.jsx("directionalLight",{color:16777215,position:[0,-800,0]}),I.jsx("primitive",{ref:l,object:e,position:[-.18,1.13,-1],scale:[.002*s[0],.002*s[1],.002*s[2]]})]}):null,n.uniforms&&n.shader?I.jsx("group",{children:I.jsxs("mesh",{name:"cube",position:[-.18,1.13,-1],rotation:[0,0,0],scale:[.002*n.meshScale[0],.002*n.meshScale[1],.002*n.meshScale[2]],ref:r,children:[I.jsx("boxGeometry",{args:n.geometrySize}),I.jsx("shaderMaterial",{customProgramCacheKey:()=>"1",side:rt,uniforms:n.uniforms,needsUpdate:!0,transparent:!0,vertexShader:n.shader.vertexShader,fragmentShader:n.shader.fragmentShader})]})}):null]}),I.jsx("group",{name:"currentLine",ref:c,children:x?I.jsx(mn,{currentLine:y,scale:1/.002*.4}):null}),I.jsx("group",{name:"lines",children:S.map(M=>I.jsx(mn,{currentLine:M,scale:1/.002*.4}))})]}):I.jsxs("group",{children:[I.jsxs("group",{children:[e?.visible?I.jsxs("group",{children:[I.jsx("hemisphereLight",{skyColor:8421504,groundColor:6316128}),I.jsx("directionalLight",{color:16777215,position:[0,-800,0]}),I.jsx("directionalLight",{color:16777215,position:[0,800,0]}),I.jsx(Ra,{firstHitOnly:!0,children:I.jsx("primitive",{ref:l,object:e,position:[0,0,0],onClick:M=>{M.object.parent.userData.name==="finalPass"&&o(M.object.name,M.object.userData.layerScope,M.object.userData.channelScope)},onPointerOver:M=>{a(M.object.name)},onPointerOut:M=>a(null)})})]}):null,n.uniforms&&n.shader?I.jsx("group",{children:I.jsxs("mesh",{scale:n.meshScale,ref:r,children:[I.jsx("boxGeometry",{args:n.geometrySize}),I.jsx("shaderMaterial",{customProgramCacheKey:()=>"1",side:rt,uniforms:n.uniforms,needsUpdate:!0,transparent:!0,vertexShader:n.shader.vertexShader,fragmentShader:n.shader.fragmentShader})]})}):null]}),I.jsx("group",{name:"lines",children:S.map(M=>I.jsx(mn,{currentLine:M,scale:1}))})]})})}function Oa(){const{controllers:i}=X();return it(()=>{i?.[0]&&i?.[1]&&(i[0]?.hand?.children?.[25]?.children?.[0]?.children?.[0]&&(i[0].hand.children[25].children[0].children[0].material.transparent=!0,i[0].hand.children[25].children[0].children[0].material.opacity=.5),i[1]?.hand?.children?.[25]?.children?.[0]?.children?.[0]&&(i[1].hand.children[25].children[0].children[0].material.transparent=!0,i[1].hand.children[25].children[0].children[0].material.opacity=.5))}),null}class Na{constructor(e,t,s,n,r){if(this.spacing=[1,1,1],this.offset=[0,0,0],this.matrix=new mr,this.matrix.identity(),this.sliceList=[],this.lowerThresholdValue=-1/0,this.upperThresholdValue=1/0,arguments.length>0){switch(this.xLength=Number(e)||1,this.yLength=Number(t)||1,this.zLength=Number(s)||1,n){case"Uint8":case"uint8":case"uchar":case"unsigned char":case"uint8_t":this.data=new Uint8Array(r);break;case"Int8":case"int8":case"signed char":case"int8_t":this.data=new Int8Array(r);break;case"Int16":case"int16":case"short":case"short int":case"signed short":case"signed short int":case"int16_t":this.data=new Int16Array(r);break;case"Uint16":case"uint16":case"ushort":case"unsigned short":case"unsigned short int":case"uint16_t":this.data=new Uint16Array(r);break;case"Int32":case"int32":case"int":case"signed int":case"int32_t":this.data=new Int32Array(r);break;case"Uint32":case"uint32":case"uint":case"unsigned int":case"uint32_t":this.data=new Uint32Array(r);break;case"longlong":case"long long":case"long long int":case"signed long long":case"signed long long int":case"int64":case"int64_t":case"ulonglong":case"unsigned long long":case"unsigned long long int":case"uint64":case"uint64_t":throw new Error("uint64_t type is not supported in JavaScript");case"Float32":case"float32":case"float":this.data=new Float32Array(r);break;case"Float64":case"float64":case"double":this.data=new Float64Array(r);break;default:this.data=new Uint8Array(r)}if(this.data.length!==this.xLength*this.yLength*this.zLength)throw new Error("lengths are not matching arrayBuffer size")}}get lowerThreshold(){return this.lowerThresholdValue}set lowerThreshold(e){this.lowerThresholdValue=e,this.sliceList.forEach(t=>{t.geometryNeedsUpdate=!0})}get upperThreshold(){return this.upperThresholdValue}set upperThreshold(e){this.upperThresholdValue=e,this.sliceList.forEach(t=>{t.geometryNeedsUpdate=!0})}getData(e,t,s){return this.data[s*this.xLength*this.yLength+t*this.xLength+e]}access(e,t,s){return s*this.xLength*this.yLength+t*this.xLength+e}reverseAccess(e){const t=Math.floor(e/(this.yLength*this.xLength)),s=Math.floor((e-t*this.yLength*this.xLength)/this.xLength);return[e-t*this.yLength*this.xLength-s*this.xLength,s,t]}map(e,t){const{length:s}=this.data,n=t||this;for(let r=0;r<s;r++)this.data[r]=e.call(n,this.data[r],r,this.data);return this}extractPerpendicularPlane(e,t){const s=new Q().identity(),n=this;let r,o,a,l;const c=new P,d=new P,u=new P,h=new P(this.xLength,this.yLength,this.zLength);switch(e){case"x":c.set(1,0,0),d.set(0,0,-1),u.set(0,-1,0),r=this.spacing[2],o=this.spacing[1],l=new P(t,0,0),s.multiply(new Q().makeRotationY(Math.PI/2)),a=(n.RASDimensions[0]-1)/2,s.setPosition(new P(t-a,0,0));break;case"y":c.set(0,1,0),d.set(1,0,0),u.set(0,0,1),r=this.spacing[0],o=this.spacing[2],l=new P(0,t,0),s.multiply(new Q().makeRotationX(-Math.PI/2)),a=(n.RASDimensions[1]-1)/2,s.setPosition(new P(0,t-a,0));break;case"z":default:c.set(0,0,1),d.set(1,0,0),u.set(0,-1,0),r=this.spacing[0],o=this.spacing[1],l=new P(0,0,t),a=(n.RASDimensions[2]-1)/2,s.setPosition(new P(0,0,t-a));break}d.applyMatrix4(n.inverseMatrix).normalize(),d.argVar="i",u.applyMatrix4(n.inverseMatrix).normalize(),u.argVar="j",c.applyMatrix4(n.inverseMatrix).normalize();const f=Math.floor(Math.abs(d.dot(h))),w=Math.floor(Math.abs(u.dot(h))),g=Math.abs(f*r),m=Math.abs(w*o);l=Math.abs(Math.round(l.applyMatrix4(n.inverseMatrix).dot(c)));const p=[new P(1,0,0),new P(0,1,0),new P(0,0,1)],x=[d,u,c].find(S=>Math.abs(S.dot(p[0]))>.9),v=[d,u,c].find(S=>Math.abs(S.dot(p[1]))>.9),y=[d,u,c].find(S=>Math.abs(S.dot(p[2]))>.9);function b(S,A){const _=x===c?l:x.arglet==="i"?S:A,E=v===c?l:v.arglet==="i"?S:A,M=y===c?l:y.arglet==="i"?S:A,R=x.dot(p[0])>0?_:n.xLength-1-_,C=v.dot(p[1])>0?E:n.yLength-1-E,L=y.dot(p[2])>0?M:n.zLength-1-M;return n.access(R,C,L)}return{iLength:f,jLength:w,sliceAccess:b,matrix:s,planeWidth:g,planeHeight:m}}computeMinMax(){let e=1/0,t=-1/0;const s=this.data.length;let n=0;for(n=0;n<s;n++)if(!Number.isNaN(this.data[n])){const r=this.data[n];e=Math.min(e,r),t=Math.max(t,r)}return this.min=e,this.max=t,[e,t]}}const za={uniforms:{u_size:{value:new P(1,1,1)},u_renderstyle:{value:0},u_renderthreshold:{value:.5},u_opacity:{value:.5},u_clim:{value:new k(.2,.8)},u_clim2:{value:new k(.2,.8)},u_clim3:{value:new k(.2,.8)},u_clim4:{value:new k(.2,.8)},u_clim5:{value:new k(.2,.8)},u_clim6:{value:new k(.2,.8)},u_xClip:{value:new k(-1,1e6)},u_yClip:{value:new k(-1,1e6)},u_zClip:{value:new k(-1,1e6)},u_data:{value:null},u_stop_geom:{value:null},u_geo_color:{value:null},u_window_size:{value:new k(1,1)},u_vol_scale:{value:new k(1,1,1)},u_physical_Pixel:{value:.5},volumeTex:{value:null},volumeTex2:{value:null},volumeTex3:{value:null},volumeTex4:{value:null},volumeTex5:{value:null},volumeTex6:{value:null},u_color:{value:new P(0,0,0)},u_color2:{value:new P(0,0,0)},u_color3:{value:new P(0,0,0)},u_color4:{value:new P(0,0,0)},u_color5:{value:new P(0,0,0)},u_color6:{value:new P(0,0,0)},u_cmdata:{value:null},near:{value:.1},far:{value:1e4},alphaScale:{value:0},dtScale:{value:1},volumeCount:{value:0},finalGamma:{value:0},boxSize:{value:new P(1,1,1)}},vertexShader:["out vec3 rayDirUnnorm;","out vec3 cameraCorrected;","uniform vec3 u_vol_scale;","uniform vec3 u_size;","varying vec3 worldSpaceCoords;","varying vec2 vUv;","varying vec4 glPosition;","uniform highp vec3 boxSize;","void main()","{","   worldSpaceCoords = position / boxSize + vec3(0.5, 0.5, 0.5); //move it from [-0.5;0.5] to [0,1]","   cameraCorrected = (inverse(modelMatrix) * vec4(cameraPosition, 1.)).xyz;","   rayDirUnnorm = position - cameraCorrected;","   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","   glPosition = gl_Position;","   vUv = uv;","}"].join(`
`),fragmentShader:["#include <packing>","precision highp float;"," precision mediump sampler3D;","in vec3 rayDirUnnorm;","in vec3 cameraCorrected;","uniform sampler3D volumeTex;","uniform sampler3D volumeTex2;","uniform sampler3D volumeTex3;","uniform sampler3D volumeTex4;","uniform sampler3D volumeTex5;","uniform sampler3D volumeTex6;","uniform vec2 u_clim;","uniform vec2 u_clim2;","uniform vec2 u_clim3;","uniform vec2 u_clim4;","uniform vec2 u_clim5;","uniform vec2 u_clim6;","uniform vec2 u_window_size;","uniform vec2 u_xClip;","uniform vec2 u_yClip;","uniform vec2 u_zClip;","uniform sampler2D u_cmdata;","uniform sampler2D u_stop_geom;","uniform sampler2D u_geo_color;","uniform vec3 u_color;","uniform vec3 u_color2;","uniform vec3 u_color3;","uniform vec3 u_color4;","uniform vec3 u_color5;","uniform vec3 u_color6;","uniform float alphaScale;","uniform float dtScale;","uniform float finalGamma;","uniform float volumeCount;","uniform highp vec3 boxSize;","uniform vec3 u_size;","uniform int u_renderstyle;","uniform float u_opacity;","uniform vec3 u_vol_scale;","uniform float near;","uniform float u_physical_Pixel;","varying vec2 vUv;","varying vec4 glPosition;","uniform float far;","varying vec3 worldSpaceCoords;","float linearize_z(float z) {","        return near * far / (far + z * (near - far));","}","vec2 intersect_hit(vec3 orig, vec3 dir) {","  vec3 boxMin = vec3(-0.5) * boxSize;","  vec3 boxMax = vec3( 0.5) * boxSize;","  if(u_xClip.x > -1.0){   boxMin.x = u_xClip.x-(boxSize.x/2.0);","   if(u_xClip.y < boxSize.x)","       boxMax.x = u_xClip.y-(boxSize.x/2.0);","  }","  if(u_yClip.x > -1.0){   boxMin.y = u_yClip.x-(boxSize.y/2.0);","   if(u_yClip.y < boxSize.y)","      boxMax.y = u_yClip.y-(boxSize.y/2.0);","  }","  if(u_zClip.x > -1.0){   boxMin.z = u_zClip.x-(boxSize.z/2.0);","   if(u_zClip.y < boxSize.z)       boxMax.z = u_zClip.y-(boxSize.z/2.0);","  }","  vec3 invDir = 1.0 / dir;","  vec3 tmin0 = (boxMin - orig) * invDir;","  vec3 tmax0 = (boxMax - orig) * invDir;","  vec3 tmin = min(tmin0, tmax0);","  vec3 tmax = max(tmin0, tmax0);","  float t0 = max(tmin.x, max(tmin.y, tmin.z));","  float t1 = min(tmax.x, min(tmax.y, tmax.z));","  return vec2(t0, t1);","}","   // Pseudo-random number gen from","   // http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/","   // with some tweaks for the range of values","       float wang_hash(int seed) {","     seed = (seed ^ 61) ^ (seed >> 16);","     seed *= 9;","     seed = seed ^ (seed >> 4);","     seed *= 0x27d4eb2d;","     seed = seed ^ (seed >> 15);","     return float(seed % 2147483647) / float(2147483647);","     }","float linear_to_srgb(float x) {","   if (x <= 0.0031308f) {","     return 12.92f * x;","   }","   return 1.055f * pow(x, 1.f / 2.4f) - 0.055f;","}","void main(void) {","  //STEP 1: Normalize the view Ray","  vec3 rayDir = normalize(rayDirUnnorm);","  //STEP 2: Intersect the ray with the volume bounds to find the interval along the ray overlapped by the volume","  vec2 t_hit = intersect_hit(cameraCorrected, rayDir);","  if (t_hit.x >= t_hit.y) {","    discard;","  }","  //No sample behind the eye","  t_hit.x = max(t_hit.x, 0.0);","  //STEP 3: Compute the step size to march through the volume grid","  ivec3 volumeTexSize = textureSize(volumeTex, 0);","  vec3 dt_vec = 1.0 / (vec3(volumeTexSize) * abs(rayDir));","  float dt = min(dt_vec.x, min(dt_vec.y, dt_vec.z));","  dt = max(1.0, dt);","  // Ray starting point, in the real space where the box may not be a cube.","  // Prevents a lost WebGL context."," float offset = wang_hash(int(gl_FragCoord.x + 640.0 * gl_FragCoord.y));"," vec3 p = cameraCorrected + (t_hit.x + offset + dt) * rayDir;","  // Most browsers do not need this initialization, but add it to be safe.","  gl_FragColor = vec4(0.0);","  p = p / boxSize + vec3(0.5);","  vec3 step = (rayDir * dt) / boxSize;","  // ","  // Initialization of some variables.","  float max_val = 0.0;","  float max_val2 = 0.0;","  float max_val3 = 0.0;","  float max_val4 = 0.0;","  float max_val5 = 0.0;","  float max_val6 = 0.0;","  vec3 rgbCombo = vec3(0.0);","  float total = 0.0;","  int max_i = 30000;","  int i = 0;","  float x = gl_FragCoord.x/u_window_size.x;","  float y = gl_FragCoord.y/u_window_size.y;","  vec3 meshPos = texture2D(u_stop_geom, vec2(x,y)).xyz;","  float dist = 1000.0;","  for (float t = t_hit.x; t < t_hit.y; t += dt) {","       if(meshPos != vec3(0.0))           dist = distance(p,meshPos);","      float val = texture(volumeTex, p.xyz).r;","      val = max(0.0, (val - u_clim[0]) / (u_clim[1] - u_clim[0]));","      rgbCombo += max(0.0, min(1.0, val)) * u_color;","      total += val;","      if(volumeCount > 1.0){           float val2 = texture(volumeTex2, p.xyz).r;","           val2 = max(0.0,(val2 - u_clim2[0]) / (u_clim2[1] - u_clim2[0]));","           rgbCombo += max(0.0, min(1.0, val2)) * u_color2;","           total += val2;","       }","       if(volumeCount > 2.0){           float val3 = texture(volumeTex3, p.xyz).r;","           val3 = max(0.0,(val3 - u_clim3[0]) / (u_clim3[1] - u_clim3[0]));","           rgbCombo += max(0.0, min(1.0, val3)) * u_color3;","           total += val3;","       }","       if(volumeCount > 3.0){           float val4 = texture(volumeTex4, p.xyz).r;","           val4 = max(0.0,(val4 - u_clim4[0]) / (u_clim4[1] - u_clim4[0]));","           rgbCombo += max(0.0, min(1.0, val4)) * u_color4;","           total += val4;","       }","       if(volumeCount > 4.0){           float val5 = texture(volumeTex5, p.xyz).r;","           val5 = max(0.0,(val5 - u_clim5[0]) / (u_clim5[1] - u_clim5[0]));","           rgbCombo += max(0.0, min(1.0, val5)) * u_color5;","           total += val5;","        }","        if(volumeCount > 5.0){           float val6 = texture(volumeTex6, p.xyz).r;","           val6 = max(0.0,(val6 - u_clim6[0]) / (u_clim6[1] - u_clim6[0]));","           rgbCombo += max(0.0, min(1.0, val6)) * u_color6;","           total += val6;","       }","       if(total > 0.0 && dist < 0.1){","           break;","       }else if(dist < 0.1){           gl_FragColor = vec4(0.0,0.0,0.0,0.0);","           break;","       }","       if(u_renderstyle == 0 && (max_val > u_clim[1] && max_val2 >= u_clim2[1] && max_val3 >= u_clim3[1] && max_val4 >= u_clim4[1] && max_val5 >= u_clim5[1] &&  max_val6 >= u_clim6[1])) break;","       if(u_renderstyle == 2){           total = min(total, 1.0);","           vec4 val_color = vec4(rgbCombo, total);","           val_color.a = 1.0 - pow(1.0 - val_color.a, 1.0);","           gl_FragColor.rgb += (1.0 - gl_FragColor.a) * val_color.a * val_color.rgb;","           gl_FragColor.a += (1.0 - gl_FragColor.a) * val_color.a * dtScale;","           if (gl_FragColor.a >= 0.95) {","               break;","           }","       }","       p += step;","  }","   gl_FragDepth = distance(worldSpaceCoords,p)*u_physical_Pixel;","   if(u_renderstyle == 0 && (max_val <  u_clim[0] && max_val2 < u_clim2[0] && max_val3 < u_clim3[0] &&   max_val4 <  u_clim4[0] && max_val5 <  u_clim5[0] && max_val6 <  u_clim6[0])){","        gl_FragColor = vec4(0,0,0,0);","   }else if(u_renderstyle == 0){","       max_val = (max_val - u_clim[0]) / (u_clim[1] - u_clim[0]);","       max_val2 = (max_val2 - u_clim2[0]) / (u_clim2[1] - u_clim2[0]);","       max_val3 = (max_val3 - u_clim3[0]) / (u_clim3[1] - u_clim3[0]);","       max_val4 = (max_val4 - u_clim4[0]) / (u_clim4[1] - u_clim4[0]);","       max_val5 = (max_val5 - u_clim5[0]) / (u_clim5[1] - u_clim5[0]);","       max_val6 = (max_val6 - u_clim6[0]) / (u_clim6[1] - u_clim6[0]);","       vec3 color = u_color * max_val;","       if(volumeCount > 1.0) color = color +  u_color2 * max_val2;","       if(volumeCount > 3.0) color = color +  u_color4 * max_val4;","       if(volumeCount > 2.0) color = color +  u_color3 * max_val3;","       if(volumeCount > 4.0) color = color +  u_color5 * max_val5;","       if(volumeCount > 5.0) color = color +  u_color6 * max_val6;","       vec3 colorCorrected = vec3(min(color[0], 1.0), min(color[1],1.0), min(color[2],1.0));","        gl_FragColor = vec4(color,1.0);","    }","    gl_FragColor.r = linear_to_srgb(gl_FragColor.r);","    gl_FragColor.g = linear_to_srgb(gl_FragColor.g);","    gl_FragColor.b = linear_to_srgb(gl_FragColor.b);","}"].join(`
`)},Ua={maximumIntensityProjection:0,minimumIntensityProjection:1,additive:2};function Fa(i,e,t,s,n,r){const{spatialRenderingMode:o}=r,a=n?.image?.instance?.getData();if(!a)return{channelsVisible:null,resolution:null,data:null,colors:null,contrastLimits:null,allChannels:null,channelTargetC:null};const l=n.image.instance,c=o==="3D",d=e[ce.PHOTOMETRIC_INTERPRETATION]==="RGB",u=e[ce.VOLUMETRIC_RENDERING_ALGORITHM],h=Ua[u],f=e[ce.SPATIAL_LAYER_VISIBLE],w=e[ce.SPATIAL_LAYER_OPACITY];l.isInterleaved();const g=d?[[255,0,0],[0,255,0],[0,0,255]]:t.map(M=>s[M][ce.SPATIAL_CHANNEL_COLOR]),m=d?[[0,255],[0,255],[0,255]]:t.map(M=>s[M][ce.SPATIAL_CHANNEL_WINDOW]||[0,255]),p=d?[f&&!0,f&&!0,f&&!0]:t.map(M=>f&&s[M][ce.SPATIAL_CHANNEL_VISIBLE]),x=d?[f&&!0,f&&!0,f&&!0]:t.map(M=>f&&l.getChannelIndex(s[M][ce.SPATIAL_TARGET_C])),v=l.getAutoTargetResolution(),y=e[ce.SPATIAL_TARGET_RESOLUTION],b=y===null||Number.isNaN(y)?v:y,S=n.image.loaders[0].channels;let A=e[ce.SPATIAL_SLICE_X],_=e[ce.SPATIAL_SLICE_Y],E=e[ce.SPATIAL_SLICE_Z];return A=A!==null?A:new k(-1,1e5),_=_!==null?_:new k(-1,1e5),E=E!==null?E:new k(-1,1e5),{channelsVisible:p,allChannels:S,channelTargetC:x,resolution:b,data:a,colors:g,contrastLimits:m,is3dMode:c,renderingMode:h,layerTransparency:w,xSlice:A,ySlice:_,zSlice:E}}function ja(i,e,t,s,n){const{images:r={},imageLayerScopes:o,imageLayerCoordination:a,imageChannelScopesByLayer:l,imageChannelCoordination:c}=i,d=o[0],u=l[d],h=a[0][d],f=c[0][d],{channelsVisible:w,allChannels:g,channelTargetC:m,resolution:p,data:x,colors:v,contrastLimits:y,is3dMode:b,renderingMode:S,layerTransparency:A,xSlice:_,ySlice:E,zSlice:M}=Fa(d,h,u,f,r[d],i);return m!==null&&(e.channelTargetC.length!==0&&(e.channelTargetC.toString()!==m.toString()||e.resolution.toString()!==p.toString())?s||n(!0):(e.channelsVisible.toString()!==w.toString()||e.colors.toString()!==v.toString()||e.is3dMode!==b||e.contrastLimits.toString()!==y.toString()||e.renderingMode.toString()!==S.toString()||e.layerTransparency.toString()!==A.toString()||e.xSlice.toString()!==_.toString()||e.ySlice.toString()!==E.toString()||e.zSlice.toString()!==M.toString())&&(t({channelsVisible:w,allChannels:g,channelTargetC:m,resolution:p,data:x,colors:v,contrastLimits:y,is3dMode:b,renderingMode:S,layerTransparency:A,xSlice:_,ySlice:E,zSlice:M}),n(!1))),{images:r,layerScope:d,imageLayerScopes:o,imageLayerCoordination:a,imageChannelScopesByLayer:l,imageChannelCoordination:c,channelsVisible:w,allChannels:g,channelTargetC:m,resolution:p,data:x,colors:v,contrastLimits:y,is3dMode:b,renderingMode:S,layerTransparency:A,xSlice:_,ySlice:E,zSlice:M}}function Vt(i,e){const[t,s]=e;return(i-t)/Math.sqrt(s**2-t**2)}function Da(i,e,t,s,n,r,o,a,l,c,d,u,h){i.boxSize.value.set(t.xLength,t.yLength,t.zLength),i.volumeTex.value=e.length>0?e[0]:null,i.volumeTex2.value=e.length>1?e[1]:null,i.volumeTex3.value=e.length>2?e[2]:null,i.volumeTex4.value=e.length>3?e[3]:null,i.volumeTex5.value=e.length>4?e[4]:null,i.volumeTex6.value=e.length>5?e[5]:null,i.near.value=.1,i.far.value=3e3,i.alphaScale.value=1,i.dtScale.value=a,i.finalGamma.value=4.5,i.volumeCount.value=e.length,i.u_size.value.set(t.xLength,t.yLength,t.zLength),i.u_stop_geom.value=null,i.u_window_size.value.set(0,0),i.u_vol_scale.value.set(1/t.xLength,1/t.yLength,1/t.zLength*2),i.u_renderstyle.value=n,i.u_clim.value.set(r.length>0?r[0][0]:null,r.length>0?r[0][1]:null),i.u_clim2.value.set(r.length>1?r[1][0]:null,r.length>1?r[1][1]:null),i.u_clim3.value.set(r.length>2?r[2][0]:null,r.length>2?r[2][1]:null),i.u_clim4.value.set(r.length>3?r[3][0]:null,r.length>3?r[3][1]:null),i.u_clim5.value.set(r.length>4?r[4][0]:null,r.length>4?r[4][1]:null),i.u_clim6.value.set(r.length>5?r[5][0]:null,r.length>5?r[5][1]:null),i.u_xClip.value.set(l[0]*(1/u[0])/h[0]*t.xLength,l[1]*(1/u[0])/h[0]*t.xLength),i.u_yClip.value.set(c[0]*(1/u[1])/h[1]*t.yLength,c[1]*(1/u[1])/h[1]*t.yLength),i.u_zClip.value.set(d[0]*(1/u[2])/h[2]*t.zLength,d[1]*(1/u[1])/h[2]*t.zLength),i.u_color.value.set(o.length>0?o[0][0]:null,o.length>0?o[0][1]:null,o.length>0?o[0][2]:null),i.u_color2.value.set(o.length>1?o[1][0]:null,o.length>1?o[1][1]:null,o.length>1?o[1][2]:null),i.u_color3.value.set(o.length>2?o[2][0]:null,o.length>2?o[2][1]:null,o.length>2?o[2][2]:null),i.u_color4.value.set(o.length>3?o[3][0]:null,o.length>3?o[3][1]:null,o.length>3?o[3][2]:null),i.u_color5.value.set(o.length>4?o[4][0]:null,o.length>4?o[4][1]:null,o.length>4?o[4][2]:null),i.u_color6.value.set(o.length>5?o[5][0]:null,o.length>5?o[5][1]:null,o.length>5?o[5][2]:null)}function Rs(i,e,t,s,n,r,o,a,l,c,d,u,h,f){const w=[],g=[],m=[];let p=null,x=a;if(x==null||!Array.isArray(x)||x.length<3)x=[{size:x?.[0]?.size??1},{size:x?.[1]?.size??1},{size:x?.[2]?.size??1}];else for(let S=0;S<x.length;S++)(!x[S]||x[S].size===void 0||x[S].size===null)&&(x[S]={size:1});if(e.forEach((S,A)=>{t[A]&&(p=i.get(S),w.push(n.get(S)),g.push([s[A][0]/255,s[A][1]/255,s[A][2]/255]),r[A][0]===0&&r[A][1]===255?m.push([Vt(o.get(S)[0],o.get(S)),Vt(o.get(S)[1],o.get(S))]):m.push([Vt(r[A][0],o.get(S)),Vt(r[A][1],o.get(S))]))}),p===null)return null;const v={},y=za,b=xn.clone(y.uniforms);return Da(b,w,p,v,l,m,g,c,d,u,h,[x[0].size,x[1].size,x[2]?x[2].size:1],f),[b,y,[1,x[1].size/x[0].size,x[2]?x[2].size/x[0].size:1],[p.xLength,p.yLength,p.zLength],[1,p.yLength/p.xLength,p.zLength/p.xLength]]}const Ha={Uint8:Uint8Array,Uint16:Uint16Array,Uint32:Uint32Array,Int8:Int8Array,Int16:Int16Array,Int32:Int32Array,Float32:Float32Array,Float64:Float64Array};async function ka({source:i,selection:e,onUpdate:t=()=>{},downsampleDepth:s=1,signal:n}){const{shape:r,labels:o,dtype:a}=i,{height:l,width:c}=pr(i),d=r[o.indexOf("z")],u=Math.max(1,Math.floor(d/s)),h=l*c,f=Ha[a],w=new f(h*u);return await Promise.all(new Array(u).fill(0).map(async(g,m)=>{const p={...e,z:m*s},{data:x}=await i.getRaster({selection:p,signal:n});let v=0;for(t({z:m,total:u,progress:.5});v<h;){const y=m*h+(h-v-1),b=(c-v-1)%c+c*Math.floor(v/c);w[y]=x[b],v+=1}t({z:m,total:u,progress:1})})),{data:w,height:l,width:c,depth:u}}function Va(i,e,t){return ka({source:t[e],selection:{t:0,c:i},downsampleDepth:2**e})}function Ga(i){const e=new Na;return e.xLength=i.width,e.yLength=i.height,e.zLength=i.depth,e.data=i.data,e}function qa(i){const e=new ur(i.data,i.xLength,i.yLength,i.zLength);return e.format=dr,e.type=hr,e.generateMipmaps=!1,e.minFilter=qt,e.magFilter=qt,e.needsUpdate=!0,e}function Xa(i){const{x:e,y:t,z:s}=i?.meta?.physicalSizes??{};return[e,t,s]}function Ka(i){const[e,t]=i.computeMinMax(),s=new Float32Array(i.data.length);for(let n=0;n<i.data.length;n++)s[n]=(i.data[n]-e)/Math.sqrt(t**2-e**2);return s}async function Wa(i,e,t,s,n,r,o){let a=null,l=null;const{shape:c,labels:d}=t[0],u=i.filter(f=>!s.has(f)||e!==o),h=await Promise.all(u.map(f=>Va(f,e,t)));return u.forEach((f,w)=>{const g=h[w];a=Ga(g);const m=a.computeMinMax();a.data=Ka(a),s.set(f,a),n.set(f,qa(a)),r.set(f,m),l=Xa(t[e])}),[s,n,r,l,[c[d.indexOf("x")],c[d.indexOf("y")],c[d.indexOf("z")]]]}function $a(i){const e=T.useRef(null),t=T.useRef(null),[s,n]=T.useState(!1),[r,o]=T.useState(!1),[a,l]=T.useState(null),[c,d]=T.useState([1,1,1]),[u,h]=T.useState({uniforms:null,shader:null,meshScale:null,geometrySize:null,boxSize:null}),[f,w]=T.useState({volumes:new Map,textures:new Map,volumeMinMax:new Map,scale:null,resolution:null,originalScale:null}),[g,m]=T.useState({channelsVisible:[],allChannels:[],channelTargetC:[],resolution:null,data:null,colors:[],contrastLimits:[],is3dMode:!1,renderingMode:null,layerTransparency:1}),[p,x]=T.useState({visible:!0,color:[1,1,1],opacity:1,multiVisible:"",multiOpacity:"",multiColor:"",data:null,obsSets:[]}),{images:v,layerScope:y,channelsVisible:b,allChannels:S,channelTargetC:A,resolution:_,data:E,colors:M,contrastLimits:R,is3dMode:C,renderingMode:L,layerTransparency:B,xSlice:F,ySlice:D,zSlice:Z}=ja(i,g,m,r,o),{obsSegmentations:J,onEntitySelected:St,segmentationLayerCoordination:$t,segmentationChannelCoordination:ye,segmentationChannelScopesByLayer:_t}=i;let kn=()=>{};const lt=[];if(ye[0][y]!==void 0){const N=ye[0][y][y],{setObsHighlight:z}=ye[1][y][y];kn=z;const O=ye[0][y][y].additionalObsSets;O!==null&&N.obsSetSelection.forEach(Y=>{const re=Y[1];O.tree[0].children.forEach(ae=>{ae.name===re&&ae.set.forEach(([j])=>{const K={name:"",id:"",color:[255,255,255]};K.name=re,K.id=j,N.obsSetColor.forEach(le=>{le.path[1]===re&&(K.color=le.color)}),lt.push(K)})})}),N.obsHighlight!==null&&lt.push({name:"",id:N.obsHighlight,color:[255,34,0]})}if(J?.[y]?.obsSegmentations&&a==null){const{scene:N,sceneOptions:z}=J[y].obsSegmentations;if(N?.children){const O=new cr,Y=new He;Y.userData.name="finalPass",N.children.forEach(ae=>{let j=ae;j.material===void 0&&(j=ae.children[0]),(j.material instanceof Ce||j.material instanceof je)&&(j.material=new On);let K=j.name.replace("mesh_","").replace("mesh","").replace("glb","").replace("_dec","").replace("_Decobj","").replace("obj","").replace("_DEc","").replace(".","").replace("_Dec","");K.includes("_")&&(K=K.split("_")[0]),j.name=K,j.userData.name=K,j.userData.layerScope=y,j.material.transparent=!0,j.material.writeDepthTexture=!0,j.material.depthTest=!0,j.material.depthWrite=!0,j.material.needsUpdate=!0,j.material.side=z?.materialSide==="back"?Ls:rt;const le=j.clone();le.geometry=j.geometry.clone(),le.geometry.translate(z?.targetX??0,z?.targetY??0,z?.targetZ??0),le.geometry.scale(z?.scaleX??1,z?.scaleY??1,z?.scaleZ??1),le.geometry.rotateX(z?.rotationX??0),le.geometry.rotateY(z?.rotationY??0),le.geometry.rotateZ(z?.rotationZ??0);const Te=j.clone();Te.material=j.material.clone(),Te.geometry=le.geometry.clone(),Y.add(Te)}),O.add(Y),O.scale.set(z?.sceneScaleX??1,z?.sceneScaleY??1,z?.sceneScaleZ??1);const re=[z?.sceneScaleX??1,z?.sceneScaleY??1,z?.sceneScaleZ??1];d(re),O.rotateX(z?.sceneRotationX??0),O.rotateY(z?.sceneRotationY??0),O.rotateZ(z?.sceneRotationZ??0),l(O)}}if(ye[0]!==void 0&&ye[0][y]!==void 0){const N=ye[0][y][y];let z="";lt.forEach(Y=>{z+=`${Y.id};${Y.color.toString()};${Y.name}`});let O="";if(p.obsSets.forEach(Y=>{O+=`${Y.id};${Y.color.toString()};${Y.name}`}),_t[y].length>1){let Y="",re="",ae="",j=!1,K=0;_t[y].forEach(le=>{const Te=ye[0][y][le];Y+=`${Te.spatialChannelColor.toString()};`,re+=`${Te.spatialChannelOpacity};`,ae+=`${Te.spatialChannelVisible};`,j|=Te.spatialChannelVisible,K+=Te.spatialChannelOpacity}),(Y!==p.multiColor||re!==p.multiOpacity||ae!==p.multiVisible)&&x({color:N.spatialChannelColor,opacity:K,visible:j,multiColor:Y,multiVisible:ae,multiOpacity:re,data:J,obsSets:lt})}else(N.spatialChannelColor.toString()!==p.color.toString()||N.spatialChannelVisible!==p.visible||N.spatialChannelOpacity!==p.opacity||z!==O)&&x({color:N.spatialChannelColor,opacity:N.spatialChannelOpacity,visible:N.spatialChannelVisible,multiColor:"",multiVisible:"",multiOpacity:"",data:J,obsSets:lt})}if(T.useEffect(()=>{if(a!==null){let N=0,z=0;for(let O=0;O<a.children.length;O++)a.children[O].userData.name==="finalPass"?z=O:N=O;a.children[z].children.forEach((O,Y)=>{let{color:re}=p;const ae=O.userData.name;if(p.obsSets.forEach(j=>{j.id===ae&&(re=j.color)}),_t[y].length>1)_t[y].forEach(j=>{const K=ye[0][y][j];K.spatialTargetC===ae&&(O.material.color.r=K.spatialChannelColor[0]/255,O.material.color.g=K.spatialChannelColor[1]/255,O.material.color.b=K.spatialChannelColor[2]/255,O.material.opacity=K.spatialChannelOpacity,O.visible=K.spatialChannelVisible,O.material.needsUpdate=!0,O.userData.layerScope=y,O.userData.channelScope=j,a.children[N].children[Y].material.needsUpdate=!0)});else{O.material.color.r=re[0]/255,O.material.color.g=re[1]/255,O.material.color.b=re[2]/255,O.material.opacity=p.opacity,O.material.visible=p.visible,O.material.needsUpdate=!0,O.userData.layerScope=y;const j=Object.keys(ye[0][y])?.[0];O.userData.channelScope=j}})}},[p,a]),v[y]?.image?.instance?.getData()!==void 0&&!r&&!s&&R!==null&&R[0][1]!==255&&C&&(o(!0),n(!0)),T.useEffect(()=>{const N=async()=>{const z=await Wa(A,_,E,f.volumes,f.textures,f.volumeMinMax,f.resolution);if(z[0]!==null)if(w({resolution:_,volumes:z[0],textures:z[1],volumeMinMax:z[2],scale:z[3]!==null?z[3]:f.scale,originalScale:z[4]}),!u.uniforms||!u.shader){const O=Rs(z[0],A,b,M,z[1],R,z[2],z[3],L,B,F,D,Z,z[4]);O!==null&&h({uniforms:O[0],shader:O[1],meshScale:O[2],geometrySize:O[3],boxSize:O[4]})}else m({channelsVisible:b,allChannels:S,channelTargetC:A,resolution:_,data:E,colors:M,contrastLimits:R,is3dMode:C,renderingMode:L,layerTransparency:B,xSlice:F,ySlice:D,zSlice:Z})};r&&(_!==g.resolution&&e.current&&(e.current.material.uniforms.volumeCount.value=0,e.current.material.uniforms.volumeTex.value=null),N(),o(!1))},[r]),T.useEffect(()=>{if(u.uniforms&&u.shader){const N=Rs(f.volumes,g.channelTargetC,g.channelsVisible,g.colors,f.textures,g.contrastLimits,f.volumeMinMax,f.scale,g.renderingMode,g.layerTransparency,g.xSlice,g.ySlice,g.zSlice,f.originalScale);if(N!==null){let z=0;g.channelsVisible.forEach(O=>{O&&z++}),o(!1),e?.current?.material?.uniforms&&(e.current.material.uniforms.u_clim.value=N[0].u_clim.value,e.current.material.uniforms.u_clim2.value=N[0].u_clim2.value,e.current.material.uniforms.u_clim3.value=N[0].u_clim3.value,e.current.material.uniforms.u_clim4.value=N[0].u_clim4.value,e.current.material.uniforms.u_clim5.value=N[0].u_clim5.value,e.current.material.uniforms.u_clim6.value=N[0].u_clim6.value,e.current.material.uniforms.u_xClip.value=N[0].u_xClip.value,e.current.material.uniforms.u_yClip.value=N[0].u_yClip.value,e.current.material.uniforms.u_zClip.value=N[0].u_zClip.value,e.current.material.uniforms.u_color.value=N[0].u_color.value,e.current.material.uniforms.u_color2.value=N[0].u_color2.value,e.current.material.uniforms.u_color3.value=N[0].u_color3.value,e.current.material.uniforms.u_color4.value=N[0].u_color4.value,e.current.material.uniforms.u_color5.value=N[0].u_color5.value,e.current.material.uniforms.u_color6.value=N[0].u_color6.value,e.current.material.uniforms.volumeTex.value=N[0].volumeTex.value,e.current.material.uniforms.volumeTex2.value=N[0].volumeTex2.value,e.current.material.uniforms.volumeTex3.value=N[0].volumeTex3.value,e.current.material.uniforms.volumeTex4.value=N[0].volumeTex4.value,e.current.material.uniforms.volumeTex5.value=N[0].volumeTex5.value,e.current.material.uniforms.volumeTex6.value=N[0].volumeTex6.value,e.current.material.uniforms.volumeCount.value=z,e.current.material.uniforms.u_renderstyle.value=g.renderingMode,e.current.material.uniforms.dtScale.value=g.layerTransparency)}else e?.current?.material?.uniforms&&(e.current.material.uniforms.volumeCount.value=0,e.current.material.uniforms.volumeTex.value=null)}},[g]),!g.is3dMode)return null;if(g.is3dMode&&(!u.uniforms||!u.shader))return I.jsxs("group",{children:[I.jsx("ambientLight",{}),I.jsx("pointLight",{position:[10,10,10]}),I.jsx(er,{color:"white",scale:20,fontWeight:1e3,children:"Loading ..."})]});const lr={segmentationGroup:a,segmentationSettings:p,segmentationSceneScale:c,renderingSettings:u,materialRef:e,highlightEntity:St,setObsHighlight:kn};return I.jsxs("group",{children:[I.jsx(xi,{}),I.jsx(Si,{}),I.jsx(Ia,{}),I.jsx(Oa,{}),I.jsx(Ba,{...lr}),I.jsx(eo,{ref:t,enableDamping:!1,dampingFactor:0,zoomDampingFactor:0,smoothZoom:!1})]})}const Qa=T.forwardRef((i,e)=>I.jsxs("div",{style:{width:"100%",height:"100%"},children:[I.jsx(zn,{mode:"AR",sessionInit:{optionalFeatures:["hand-tracking"]},style:{border:"none",background:"rgba(0, 0, 0, 0.0)",zIndex:1,position:"absolute"},children:t=>t!=="unsupported"?I.jsx("div",{style:{border:"1px solid white",padding:"12px 24px",borderRadius:"4px",background:"rgba(0, 0, 0, 0.1)",color:"white",font:"normal 0.8125rem sans-serif",outline:"none",cursor:"pointer"},children:t==="entered"?"Exit AR":"Enter AR"}):null}),I.jsx(Jr,{style:{position:"absolute",top:0,left:0},camera:{fov:50,up:[0,1,0],position:[0,0,800],near:.1,far:3e3},gl:{antialias:!0,logarithmicDepthBuffer:!1},ref:e,children:I.jsx(uo,{children:I.jsx($a,{...i})})})]}));export{Qa as SpatialWrapper};
